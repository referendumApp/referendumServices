name: Deploy Services

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to (prod/dev)'
        required: true
        default: 'dev'

env:
  AWS_ACCOUNT_ID: 842675976781
  AWS_REGION: us-east-2
  ECR_REPOSITORY_API: referendum/api
  ECR_REPOSITORY_PIPELINE: referendum/pipeline
  POSTGRES_PASSWORD_SECRET_NAME: rds!db-a5c629ff-4d6e-4d68-9680-6cdab848369c
  API_ACCESS_TOKEN_SECRET_NAME: /system/API_ACCESS_TOKEN
  SECRET_KEY_SECRET_NAME: /system/SECRET_KEY
  PIPELINE_CLUSTER: ETLCluster
  PIPELINE_TASK_DEFINITION: load-referendum-from-legiscan

permissions:
  contents: write

jobs:
  update-version:
    if: github.event_name == 'push'
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{ steps.bump_version.outputs.new_version }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      with:
        fetch-depth: 0

    - name: Get current version
      id: get_version
      run: echo "current_version=$(cat version.txt)" >> $GITHUB_OUTPUT

    - name: Bump version
      id: bump_version
      run: |
        current_version=${{ steps.get_version.outputs.current_version }}
        if [[ "${{ github.event.head_commit.message }}" == *"#major"* ]]; then
          new_version=$(echo $current_version | awk -F. '{$1 = $1 + 1; $2 = 0; $3 = 0} 1' | sed 's/ /./g')
        elif [[ "${{ github.event.head_commit.message }}" == *"#minor"* ]]; then
          new_version=$(echo $current_version | awk -F. '{$2 = $2 + 1; $3 = 0} 1' | sed 's/ /./g')
        else
          new_version=$(echo $current_version | awk -F. '{$3 = $3 + 1} 1' | sed 's/ /./g')
        fi
        echo $new_version > version.txt
        echo "new_version=$new_version" >> $GITHUB_OUTPUT

    - name: Commit version update
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add version.txt
        git commit -m "Bump version to ${{ steps.bump_version.outputs.new_version }}"

    - name: Push changes
      uses: ad-m/github-push-action@master
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        branch: main

    - name: Create Tag
      run: |
        git tag v${{ steps.bump_version.outputs.new_version }}
        git push origin v${{ steps.bump_version.outputs.new_version }}

  set-deployment-vars:
    runs-on: ubuntu-latest
    outputs:
      deploy_env: ${{ steps.set-vars.outputs.deploy_env }}
      image_tag: ${{ steps.set-vars.outputs.image_tag }}
    steps:
    - name: Set deployment variables
      id: set-vars
      run: |
        if [[ "${{ github.event_name }}" == "push" ]]; then
          echo "deploy_env=prod" >> $GITHUB_OUTPUT
          echo "image_tag=prod-${{ github.sha }}" >> $GITHUB_OUTPUT
        else
          echo "deploy_env=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          echo "image_tag=${{ github.event.inputs.environment }}-${{ github.sha }}" >> $GITHUB_OUTPUT
        fi

  deploy-api:
    needs: [set-deployment-vars, update-version]
    if: always() && (needs.update-version.result == 'success' || needs.update-version.result == 'skipped')
    runs-on: ubuntu-latest
    env:
      DEPLOY_ENV: ${{ needs.set-deployment-vars.outputs.deploy_env }}
      IMAGE_TAG: ${{ needs.set-deployment-vars.outputs.image_tag }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1

    - name: Set additional deployment variables
      run: |
        echo "PORT_MAPPING=$([ "$DEPLOY_ENV" == "prod" ] && echo "80:80" || echo "8080:80")" >> $GITHUB_ENV
        
        # Get EC2 Instance ID from SSM Parameter Store based on environment
        EC2_INSTANCE_ID_PARAM="/$(echo $DEPLOY_ENV | tr '[:upper:]' '[:lower:]')/API_EC2_INSTANCE_ID"
        EC2_INSTANCE_ID=$(aws ssm get-parameter --name $EC2_INSTANCE_ID_PARAM --query "Parameter.Value" --output text)
        echo "EC2_INSTANCE_ID=$EC2_INSTANCE_ID" >> $GITHUB_ENV

    - name: Build, tag, and push image to Amazon ECR
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
      run: |
        set -e
        docker compose --profile api build
        docker tag referendumservices-api:latest $ECR_REGISTRY/$ECR_REPOSITORY_API:${{ env.IMAGE_TAG }}
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_API:${{ env.IMAGE_TAG }}

    - name: Deploy to EC2
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
      run: |
        set -e
        echo "Deploying to EC2..."
        DEPLOY_COMMAND_OUTPUT=$(aws ssm send-command \
          --instance-ids "${{ env.EC2_INSTANCE_ID }}" \
          --document-name "AWS-RunShellScript" \
          --parameters '{
            "commands": [
              "set -e",
              "aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ steps.login-ecr.outputs.registry }}",
              "docker pull ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_API }}:${{ env.IMAGE_TAG }} >/dev/null",
              "docker stop ${{ env.DEPLOY_ENV }}-app || true",
              "docker rm ${{ env.DEPLOY_ENV }}-app || true",
              "SSM_PARAMS_JSON=$(aws ssm get-parameters-by-path --path /${{ env.DEPLOY_ENV }}/ --with-decryption --query \"Parameters[*].{Name:Name,Value:Value}\" --output json)",
              "ENV_VARS=$(echo \"$SSM_PARAMS_JSON\" | jq -r \".[] | \\\" -e \\\" + .Name + \\\"=\\\" + .Value\" | sed \"s/\\/[^\\/]*\\///g\" | tr \"\\n\" \" \")",
              "POSTGRES_SECRET=$(aws secretsmanager get-secret-value --secret-id ${{ env.POSTGRES_PASSWORD_SECRET_NAME }} --query SecretString --output text)",
              "POSTGRES_PASSWORD=$(echo $POSTGRES_SECRET | jq -r '.password')",
              "API_ACCESS_TOKEN_SECRET=$(aws secretsmanager get-secret-value --secret-id ${{ env.API_ACCESS_TOKEN_SECRET_NAME }} --query SecretString --output text)",
              "API_ACCESS_TOKEN=$(echo $API_ACCESS_TOKEN_SECRET | jq -r '.token')",
              "SECRET_KEY_SECRET=$(aws secretsmanager get-secret-value --secret-id ${{ env.SECRET_KEY_SECRET_NAME }} --query SecretString --output text)",
              "SECRET_KEY=$(echo $SECRET_KEY_SECRET | jq -r '.token')",
              "docker run -d --name ${{ env.DEPLOY_ENV }}-app -p ${{ env.PORT_MAPPING }} -e ENVIRONMENT=${{ env.DEPLOY_ENV }} -e POSTGRES_PASSWORD=\"$POSTGRES_PASSWORD\" -e API_ACCESS_TOKEN=\"$API_ACCESS_TOKEN\" -e SECRET_KEY=\"$SECRET_KEY\" $ENV_VARS ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_API }}:${{ env.IMAGE_TAG }}",
              "docker container prune -f",
              "docker image prune -af",
              "docker network prune -f",
              "docker volume prune -af",
              "echo ${{ env.DEPLOY_ENV }} deployment completed"
            ]
          }' \
          --output json)
        
        DEPLOY_COMMAND_ID=$(echo "$DEPLOY_COMMAND_OUTPUT" | jq -r '.Command.CommandId')
        
        echo "Deployment command ID: $DEPLOY_COMMAND_ID"
        
        # Wait for the command to complete and check its status
        while true; do
          COMMAND_RESULT=$(aws ssm list-command-invocations \
            --command-id "$DEPLOY_COMMAND_ID" \
            --details \
            --output json)
          
          STATUS=$(echo "$COMMAND_RESULT" | jq -r '.CommandInvocations[0].Status')
          
          if [ "$STATUS" = "Success" ]; then
            echo "Deployment command executed successfully"
            break
          elif [ "$STATUS" = "Failed" ]; then
            echo "Deployment command failed"
            echo "Command output:"
            echo "$COMMAND_RESULT" | jq -r '.CommandInvocations[0].CommandPlugins[0].Output'
            exit 1
          elif [ "$STATUS" = "TimedOut" ]; then
            echo "Deployment command timed out"
            echo "Command output:"
            echo "$COMMAND_RESULT" | jq -r '.CommandInvocations[0].CommandPlugins[0].Output'
            exit 1
          fi
          
          echo "Waiting for deployment command to complete... Current status: $STATUS"
          sleep 10
        done

    - name: Verify Deployment
      run: |
        set -e
        echo "Verifying deployment..."
        PORT="${{ env.DEPLOY_ENV == 'prod' && '80' || '8080' }}"
        MAX_RETRIES=5
        RETRY_INTERVAL=10
        
        for i in $(seq 1 $MAX_RETRIES); do
          echo "Attempt $i of $MAX_RETRIES"
          HEALTH_CHECK_COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${{ env.EC2_INSTANCE_ID }}" \
            --document-name "AWS-RunShellScript" \
            --parameters "{\"commands\":[\"curl -s -o /dev/null -w \\\"%{http_code}\\\" http://localhost:$PORT/health\"]}" \
            --output text \
            --query "Command.CommandId")
          
          sleep $RETRY_INTERVAL
          
          HEALTH_CHECK_STATUS_CODE=$(aws ssm list-command-invocations \
            --command-id "$HEALTH_CHECK_COMMAND_ID" \
            --details \
            --output text \
            --query "CommandInvocations[].CommandPlugins[].Output")
          
          if [ "$HEALTH_CHECK_STATUS_CODE" == "200" ]; then
            echo "Deployment verified successfully"
            echo "Updating stable tag..."
            docker tag ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_API }}:${{ env.IMAGE_TAG }} ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_API }}:${{ env.DEPLOY_ENV }}-stable
            docker push ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_API }}:${{ env.DEPLOY_ENV }}-stable
            echo "Deployment successful"
            exit 0
          fi
          
          echo "Health check failed. Status code: $HEALTH_CHECK_STATUS_CODE"
        done
        
        echo "Deployment verification failed after $MAX_RETRIES attempts"
        echo "Rolling back to previous stable version..."
        aws ssm send-command \
          --instance-ids "${{ env.EC2_INSTANCE_ID }}" \
          --document-name "AWS-RunShellScript" \
          --parameters '{
            "commands": [
              "docker stop ${{ env.DEPLOY_ENV }}-app || true",
              "docker rm ${{ env.DEPLOY_ENV }}-app || true",
              "docker rmi ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_API }}:${{ env.IMAGE_TAG }} || true",
              "SSM_PARAMS_JSON=$(aws ssm get-parameters-by-path --path /${{ env.DEPLOY_ENV }}/ --with-decryption --query \"Parameters[*].{Name:Name,Value:Value}\" --output json)",
              "ENV_VARS=$(echo \"$SSM_PARAMS_JSON\" | jq -r \".[] | \\\" -e \\\" + .Name + \\\"=\\\" + .Value\" | sed \"s/\\/[^\\/]*\\///g\" | tr \"\\n\" \" \")",
              "POSTGRES_SECRET=$(aws secretsmanager get-secret-value --secret-id ${{ env.POSTGRES_PASSWORD_SECRET_NAME }} --query SecretString --output text)",
              "POSTGRES_PASSWORD=$(echo $POSTGRES_SECRET | jq -r '.password')",
              "API_ACCESS_TOKEN_SECRET=$(aws secretsmanager get-secret-value --secret-id ${{ env.API_ACCESS_TOKEN_SECRET_NAME }} --query SecretString --output text)",
              "API_ACCESS_TOKEN=$(echo $API_ACCESS_TOKEN_SECRET | jq -r '.token')",
              "SECRET_KEY_SECRET=$(aws secretsmanager get-secret-value --secret-id ${{ env.SECRET_KEY_SECRET_NAME }} --query SecretString --output text)",
              "SECRET_KEY=$(echo $SECRET_KEY_SECRET | jq -r '.token')",
              "docker run -d --name ${{ env.DEPLOY_ENV }}-app -p ${{ env.PORT_MAPPING }} -e POSTGRES_PASSWORD=\"$POSTGRES_PASSWORD\" -e API_ACCESS_TOKEN=\"$API_ACCESS_TOKEN\" -e SECRET_KEY=\"$SECRET_KEY\" $ENV_VARS ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_API }}:${{ env.DEPLOY_ENV }}-stable"
            ]
          }'
        exit 1

  deploy-pipeline:
    needs: [set-deployment-vars, update-version]
    if: always() && (needs.update-version.result == 'success' || needs.update-version.result == 'skipped')
    runs-on: ubuntu-latest
    env:
      DEPLOY_ENV: ${{ needs.set-deployment-vars.outputs.deploy_env }}
      IMAGE_TAG: ${{ needs.set-deployment-vars.outputs.image_tag }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1

    - name: Build, tag, and push pipeline image to Amazon ECR
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
      run: |
        docker build --target pipeline -t $ECR_REGISTRY/$ECR_REPOSITORY_PIPELINE:${{ env.IMAGE_TAG }} .
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY_PIPELINE:${{ env.IMAGE_TAG }} $ECR_REGISTRY/$ECR_REPOSITORY_PIPELINE:${{ env.DEPLOY_ENV }}-stable

        if [[ "${{ github.event_name }}" == "push" && "${{ env.DEPLOY_ENV }}" == "prod" ]]; then
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY_PIPELINE:${{ env.IMAGE_TAG }} $ECR_REGISTRY/$ECR_REPOSITORY_PIPELINE:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY_PIPELINE:latest
        fi

        docker push $ECR_REGISTRY/$ECR_REPOSITORY_PIPELINE:${{ env.IMAGE_TAG }}
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_PIPELINE:${{ env.DEPLOY_ENV }}-stable

    - name: Update ECS Task Definition
      run: |
        # Get environment variables
        SSM_PARAMS_JSON=$(aws ssm get-parameters-by-path --path /${{ env.DEPLOY_ENV }}/ --with-decryption --query "Parameters[*].{Name:Name,Value:Value}" --output json)
        ENV_VARS=$(echo "$SSM_PARAMS_JSON" | jq -r '[.[] | {
          "name": (.Name | split("/")[-1]),
          "value": .Value
        }]')
        
        ENV_VARS=$(echo "$ENV_VARS" | jq --arg env "${{ env.DEPLOY_ENV }}" '
          . + [
            {"name": "ENVIRONMENT", "value": $env}
          ]
        ')
    
        TASK_DEFINITION=$(aws ecs describe-task-definition --task-definition ${{ env.PIPELINE_TASK_DEFINITION }} --query taskDefinition --output json)
        
        NEW_TASK_DEFINITION=$(
          echo $TASK_DEFINITION |
          jq \
            --arg IMAGE "${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_PIPELINE }}:${{ env.IMAGE_TAG }}" \
            --argjson ENV_VARS "$ENV_VARS" \
            --arg SECRET_ARN "arn:aws:secretsmanager:${{ env.AWS_REGION }}:${{ env.AWS_ACCOUNT_ID }}:secret:${{ env.POSTGRES_PASSWORD_SECRET_NAME }}" \
            '
              del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy) |
              .containerDefinitions[0].image = $IMAGE |
              .containerDefinitions[0].environment = $ENV_VARS |
              .containerDefinitions[0].secrets = [
                {
                  "name": "POSTGRES_PASSWORD",
                  "valueFrom": ($SECRET_ARN + ":password::")
                }
              ] |
              .cpu = "1024" |
              .memory = "3072" |
              .networkMode = "awsvpc"
            '
        )
        
        echo $NEW_TASK_DEFINITION > task-definition.json
        aws ecs register-task-definition --cli-input-json file://task-definition.json


    - name: Set up EventBridge rule for weekly pipeline run
      run: |
        TASK_DEFINITION_ARN=$(aws ecs describe-task-definition --task-definition ${{ env.PIPELINE_TASK_DEFINITION }} --query taskDefinition.taskDefinitionArn --output text)
        CLUSTER_ARN=$(aws ecs describe-clusters --clusters ${{ env.PIPELINE_CLUSTER }} --query 'clusters[0].clusterArn' --output text)
        RULE_NAME="weekly-pipeline-run"
        
        aws events put-rule \
          --name $RULE_NAME \
          --schedule-expression "cron(0 0 ? * SUN *)" \
          --state ENABLED

        aws events put-targets \
          --rule $RULE_NAME \
          --targets "[{
            \"Id\": \"1\",
            \"Arn\": \"$CLUSTER_ARN\",
            \"RoleArn\": \"${{ secrets.ECS_EVENTS_ROLE_ARN }}\", 
            \"EcsParameters\": {
              \"TaskDefinitionArn\": \"$TASK_DEFINITION_ARN\",
              \"TaskCount\": 1,
              \"LaunchType\": \"FARGATE\",
              \"NetworkConfiguration\": {
                \"awsvpcConfiguration\": {
                  \"Subnets\": [\"subnet-030216eccd9d8d317\"],
                  \"SecurityGroups\": [\"sg-0c0a90439deaf8b68\",\"sg-0d65a5b9089171007\"],
                  \"AssignPublicIp\": \"DISABLED\"
                }
              }
            }
          }]"

    - name: Run pipeline task
      run: |
        aws ecs run-task \
          --cluster ${{ env.PIPELINE_CLUSTER }} \
          --task-definition ${{ env.PIPELINE_TASK_DEFINITION }} \
          --launch-type FARGATE \
          --network-configuration "awsvpcConfiguration={subnets=[subnet-030216eccd9d8d317],securityGroups=[sg-0c0a90439deaf8b68,sg-0d65a5b9089171007],assignPublicIp=DISABLED}" \
          --tags key=Environment,value=${{ env.DEPLOY_ENV }}