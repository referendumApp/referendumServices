name: Deploy API to AWS

on:
  workflow_run:
    workflows: ["Update Version"]
    types:
      - completed
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to (prod/dev)'
        required: true
        default: 'dev'

env:
  AWS_REGION: us-east-2
  ECR_REPOSITORY: referendum/api
  EC2_INSTANCE_ID: i-08edd9a77b42449b2
  POSTGRES_PASSWORD_SECRET_NAME: rds!db-a5c629ff-4d6e-4d68-9680-6cdab848369c
  API_ACCESS_TOKEN_SECRET_NAME: /system/API_ACCESS_TOKEN
  SECRET_KEY_SECRET_NAME: /system/SECRET_KEY

permissions:
  contents: write

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1

    - name: Set deployment variables
      run: |
        if [[ "${{ github.event_name }}" == "workflow_run" ]]; then
          DEPLOY_ENV="prod"
        else
          DEPLOY_ENV="${{ github.event.inputs.environment }}"
        fi
        echo "DEPLOY_ENV=$DEPLOY_ENV" >> $GITHUB_ENV
        echo "IMAGE_TAG=$DEPLOY_ENV-${{ github.sha }}" >> $GITHUB_ENV
        echo "PORT_MAPPING=$([ "$DEPLOY_ENV" == "prod" ] && echo "80:80" || echo "8080:80")" >> $GITHUB_ENV

    - name: Build, tag, and push image to Amazon ECR
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
      run: |
        set -e
        docker compose --profile api build
        docker tag referendumservices-api:latest $ECR_REGISTRY/$ECR_REPOSITORY:${{ env.IMAGE_TAG }}
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:${{ env.IMAGE_TAG }}

    - name: Deploy to EC2
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
      run: |
        set -e
        echo "Deploying to EC2..."
        DEPLOY_COMMAND_OUTPUT=$(aws ssm send-command \
          --instance-ids "${{ env.EC2_INSTANCE_ID }}" \
          --document-name "AWS-RunShellScript" \
          --parameters '{
            "commands": [
              "set -e",
              "aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ steps.login-ecr.outputs.registry }}",
              "docker pull ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG }} >/dev/null",
              "docker stop ${{ env.DEPLOY_ENV }}-app || true",
              "docker rm ${{ env.DEPLOY_ENV }}-app || true",
              "SSM_PARAMS_JSON=$(aws ssm get-parameters-by-path --path /${{ env.DEPLOY_ENV }}/ --with-decryption --query \"Parameters[*].{Name:Name,Value:Value}\" --output json)",
              "ENV_VARS=$(echo \"$SSM_PARAMS_JSON\" | jq -r \".[] | \\\" -e \\\" + .Name + \\\"=\\\" + .Value\" | sed \"s/\\/[^\\/]*\\///g\" | tr \"\\n\" \" \")",
              "POSTGRES_SECRET=$(aws secretsmanager get-secret-value --secret-id ${{ env.POSTGRES_PASSWORD_SECRET_NAME }} --query SecretString --output text)",
              "POSTGRES_PASSWORD=$(echo $POSTGRES_SECRET | jq -r '.password')",
              "API_ACCESS_TOKEN_SECRET=$(aws secretsmanager get-secret-value --secret-id ${{ env.API_ACCESS_TOKEN_SECRET_NAME }} --query SecretString --output text)",
              "API_ACCESS_TOKEN=$(echo $API_ACCESS_TOKEN_SECRET | jq -r '.token')",
              "SECRET_KEY_SECRET=$(aws secretsmanager get-secret-value --secret-id ${{ env.SECRET_KEY_SECRET_NAME }} --query SecretString --output text)",
              "SECRET_KEY=$(echo $SECRET_KEY_SECRET | jq -r '.token')",
              "docker run -d --name ${{ env.DEPLOY_ENV }}-app -p ${{ env.PORT_MAPPING }} -e POSTGRES_PASSWORD=\"$POSTGRES_PASSWORD\" -e API_ACCESS_TOKEN=\"$API_ACCESS_TOKEN\" -e SECRET_KEY=\"$SECRET_KEY\" $ENV_VARS ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG }}",
              "docker container prune -f",
              "docker image prune -af",
              "docker network prune -f",
              "docker volume prune -af",
              "echo ${{ env.DEPLOY_ENV }} deployment completed"
            ]
          }' \
          --output json)
        
        DEPLOY_COMMAND_ID=$(echo "$DEPLOY_COMMAND_OUTPUT" | jq -r '.Command.CommandId')
        
        echo "Deployment command ID: $DEPLOY_COMMAND_ID"
        
        # Wait for the command to complete and check its status
        while true; do
          COMMAND_RESULT=$(aws ssm list-command-invocations \
            --command-id "$DEPLOY_COMMAND_ID" \
            --details \
            --output json)
          
          STATUS=$(echo "$COMMAND_RESULT" | jq -r '.CommandInvocations[0].Status')
          
          if [ "$STATUS" = "Success" ]; then
            echo "Deployment command executed successfully"
            break
          elif [ "$STATUS" = "Failed" ]; then
            echo "Deployment command failed"
            echo "Command output:"
            echo "$COMMAND_RESULT" | jq -r '.CommandInvocations[0].CommandPlugins[0].Output'
            exit 1
          elif [ "$STATUS" = "TimedOut" ]; then
            echo "Deployment command timed out"
            echo "Command output:"
            echo "$COMMAND_RESULT" | jq -r '.CommandInvocations[0].CommandPlugins[0].Output'
            exit 1
          fi
          
          echo "Waiting for deployment command to complete... Current status: $STATUS"
          sleep 10
        done

    - name: Verify Deployment
      run: |
        set -e
        echo "Verifying deployment..."
        PORT="${{ env.DEPLOY_ENV == 'prod' && '80' || '8080' }}"
        MAX_RETRIES=5
        RETRY_INTERVAL=10
        
        for i in $(seq 1 $MAX_RETRIES); do
          echo "Attempt $i of $MAX_RETRIES"
          HEALTH_CHECK_COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${{ env.EC2_INSTANCE_ID }}" \
            --document-name "AWS-RunShellScript" \
            --parameters "{\"commands\":[\"curl -s -o /dev/null -w \\\"%{http_code}\\\" http://localhost:$PORT/health\"]}" \
            --output text \
            --query "Command.CommandId")
          
          sleep $RETRY_INTERVAL
          
          HEALTH_CHECK_STATUS_CODE=$(aws ssm list-command-invocations \
            --command-id "$HEALTH_CHECK_COMMAND_ID" \
            --details \
            --output text \
            --query "CommandInvocations[].CommandPlugins[].Output")
          
          if [ "$HEALTH_CHECK_STATUS_CODE" == "200" ]; then
            echo "Deployment verified successfully"
            echo "Updating stable tag..."
            docker tag ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG }} ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ env.DEPLOY_ENV }}-stable
            docker push ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ env.DEPLOY_ENV }}-stable
            echo "Deployment successful"
            exit 0
          fi
          
          echo "Health check failed. Status code: $HEALTH_CHECK_STATUS_CODE"
        done
        
        echo "Deployment verification failed after $MAX_RETRIES attempts"
        echo "Rolling back to previous stable version..."
        aws ssm send-command \
          --instance-ids "${{ env.EC2_INSTANCE_ID }}" \
          --document-name "AWS-RunShellScript" \
          --parameters '{
            "commands": [
              "docker stop ${{ env.DEPLOY_ENV }}-app || true",
              "docker rm ${{ env.DEPLOY_ENV }}-app || true",
              "docker rmi ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG }} || true",
              "SSM_PARAMS_JSON=$(aws ssm get-parameters-by-path --path /${{ env.DEPLOY_ENV }}/ --with-decryption --query \"Parameters[*].{Name:Name,Value:Value}\" --output json)",
              "ENV_VARS=$(echo \"$SSM_PARAMS_JSON\" | jq -r \".[] | \\\" -e \\\" + .Name + \\\"=\\\" + .Value\" | sed \"s/\\/[^\\/]*\\///g\" | tr \"\\n\" \" \")",
              "POSTGRES_SECRET=$(aws secretsmanager get-secret-value --secret-id ${{ env.POSTGRES_PASSWORD_SECRET_NAME }} --query SecretString --output text)",
              "POSTGRES_PASSWORD=$(echo $POSTGRES_SECRET | jq -r '.password')",
              "API_ACCESS_TOKEN_SECRET=$(aws secretsmanager get-secret-value --secret-id ${{ env.API_ACCESS_TOKEN_SECRET_NAME }} --query SecretString --output text)",
              "API_ACCESS_TOKEN=$(echo $API_ACCESS_TOKEN_SECRET | jq -r '.token')",
              "SECRET_KEY_SECRET=$(aws secretsmanager get-secret-value --secret-id ${{ env.SECRET_KEY_SECRET_NAME }} --query SecretString --output text)",
              "SECRET_KEY=$(echo $SECRET_KEY_SECRET | jq -r '.token')",
              "docker run -d --name ${{ env.DEPLOY_ENV }}-app -p ${{ env.PORT_MAPPING }} -e POSTGRES_PASSWORD=\"$POSTGRES_PASSWORD\" -e API_ACCESS_TOKEN=\"$API_ACCESS_TOKEN\" -e SECRET_KEY=\"$SECRET_KEY\" $ENV_VARS ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ env.DEPLOY_ENV }}-stable"
            ]
          }'
        exit 1

    - name: Get version and create GitHub Release
      if: success() && github.event_name == 'workflow_run' && github.ref == 'refs/heads/main'
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        set -e
        set -x
    
        # Read version
        if [ ! -f version.txt ]; then
          log_error "version.txt file not found"
          exit 1
        fi
        current_version=$(cat version.txt)
        echo "Current version: $current_version"
        echo "current_version=$current_version" >> $GITHUB_ENV
    
        version="$current_version"
    
        # Generate release notes
        echo "Generating release notes for version $version"
        echo "# Release Notes for version $version" > release_notes.md
        echo "" >> release_notes.md
        echo "## Changes in this release:" >> release_notes.md
        echo "" >> release_notes.md
    
        # Fetch tags and recent history
        git fetch --tags --depth=100 || log_error "Failed to fetch git history"
        git log --oneline -n 5 || log_error "Failed to retrieve recent git log"
    
        # Get commits since the last tag
        last_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
        echo "Last tag: $last_tag"
    
        if [ -z "$last_tag" ]; then
          git log --pretty=format:"- %s (%h)" >> release_notes.md || log_error "Failed to get git log"
        else
          git log --pretty=format:"- %s (%h)" $last_tag..HEAD >> release_notes.md || log_error "Failed to get git log since last tag"
        fi
    
        # Add any breaking changes
        echo "" >> release_notes.md
        echo "## Breaking Changes:" >> release_notes.md
        git log --pretty=format:"- %s (%h)" $last_tag..HEAD | grep -i "BREAKING CHANGE" >> release_notes.md || true
    
        # Add a list of contributors
        echo "" >> release_notes.md
        echo "## Contributors:" >> release_notes.md
        git log --pretty=format:"- %an" $last_tag..HEAD | sort | uniq >> release_notes.md || log_error "Failed to get contributors"
    
        # Print release notes content
        echo "Release notes content:"
        cat release_notes.md
    
        # Check GitHub CLI authentication
        gh auth status || log_error "GitHub CLI is not authenticated"
    
        # Check if release already exists
        if gh release view "API v$version" &> /dev/null; then
          log_error "Release API v$version already exists"
          exit 1
        fi
    
        # Create the GitHub release
        echo "Creating GitHub release..."
        if ! gh release create "API v$version" \
          --title "API Release $version" \
          --notes-file release_notes.md \
          --target ${{ github.sha }}; then
          log_error "Failed to create release"
          exit 1
        fi
    
        echo "Release created successfully"
