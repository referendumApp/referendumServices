diff --git a/.github/workflows/deploy.yml b/.github/workflows/deploy.yml
index db83490..c5c4ccf 100644
--- a/.github/workflows/deploy.yml
+++ b/.github/workflows/deploy.yml
@@ -1,4 +1,4 @@
-name: Deploy Data Services & Pipeline
+name: Deploy Services
 
 on:
   push:
diff --git a/.github/workflows/user_deploy.yml b/.github/workflows/user_deploy.yml
deleted file mode 100644
index e5ec618..0000000
--- a/.github/workflows/user_deploy.yml
+++ /dev/null
@@ -1,302 +0,0 @@
-name: Deploy User Service
-
-on:
-  push:
-    branches:
-      - main
-    paths:
-      - "user_service/**"
-      - ".github/workflows/user_deploy.yml"
-  workflow_dispatch:
-    inputs:
-      environment:
-        description: 'Environment to deploy to'
-        required: true
-        default: 'dev'
-        type: 'choice'
-        options:
-          - dev
-          - prod
-      bump_version:
-        description: 'Version bump type (only used for production)'
-        required: false
-        default: 'patch'
-        type: 'choice'
-        options:
-          - patch
-          - minor
-          - major
-
-env:
-  AWS_ACCOUNT_ID: 842675976781
-  AWS_REGION: us-east-2
-  ECR_REPOSITORY_API: referendum/user-api
-  ECR_REPOSITORY_PIPELINE: referendum/pipeline
-  POSTGRES_PASSWORD_SECRET_NAME: rds!db-a5c629ff-4d6e-4d68-9680-6cdab848369c
-  SECRET_KEY_SECRET_NAME: /system/SECRET_KEY
-  S3_ACCESS_CREDENTIALS_SECRET_NAME: /system/S3_BILL_TEXTS_CREDENTIALS
-
-permissions:
-  contents: write
-
-jobs:
-  set-deployment-vars:
-    runs-on: ubuntu-latest
-    outputs:
-      deploy_env: ${{ steps.set-vars.outputs.deploy_env }}
-      image_tag: ${{ steps.set-vars.outputs.image_tag }}
-    steps:
-    - name: Set deployment variables
-      id: set-vars
-      run: |
-        # Default to dev for push to main, use input for manual trigger
-        if [[ "${{ github.event_name }}" == "push" ]]; then
-          echo "deploy_env=dev" >> $GITHUB_OUTPUT
-          echo "image_tag=dev-${{ github.sha }}" >> $GITHUB_OUTPUT
-        else
-          echo "deploy_env=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
-          echo "image_tag=${{ github.event.inputs.environment }}-${{ github.sha }}" >> $GITHUB_OUTPUT
-        fi
-
-  update-version:
-    needs: [set-deployment-vars]
-    if: needs.set-deployment-vars.outputs.deploy_env == 'prod'
-    runs-on: ubuntu-latest
-    outputs:
-      new_version: ${{ steps.bump_version.outputs.new_version }}
-      previous_version: ${{ steps.get_version.outputs.current_version }}
-    steps:
-    - name: Checkout code
-      uses: actions/checkout@v3
-      with:
-        fetch-depth: 0
-
-    - name: Get current version
-      id: get_version
-      run: echo "current_version=$(cat ./user_service/version.txt)" >> $GITHUB_OUTPUT
-
-    - name: Bump version
-      id: bump_version
-      run: |
-        current_version=${{ steps.get_version.outputs.current_version }}
-        bump_type="${{ github.event.inputs.bump_version }}"
-        
-        if [[ "$bump_type" == "major" ]]; then
-          new_version=$(echo $current_version | awk -F. '{$1 = $1 + 1; $2 = 0; $3 = 0} 1' | sed 's/ /./g')
-        elif [[ "$bump_type" == "minor" ]]; then
-          new_version=$(echo $current_version | awk -F. '{$2 = $2 + 1; $3 = 0} 1' | sed 's/ /./g')
-        else
-          new_version=$(echo $current_version | awk -F. '{$3 = $3 + 1} 1' | sed 's/ /./g')
-        fi
-        echo $new_version > ./user_service/version.txt
-        echo "new_version=$new_version" >> $GITHUB_OUTPUT
-
-    - name: Get commit information
-      id: get_commits
-      run: |
-        # Get the tag of the previous version or default to the first commit if no tags exist
-        PREVIOUS_TAG=$(git tag --sort=-v:refname | grep "user-service-v" | head -n 1 || git rev-list --max-parents=0 HEAD)
-        
-        # Store commit logs between the previous tag and HEAD
-        git log $PREVIOUS_TAG..HEAD --pretty=format:"%h %s" > commit_log.txt
-        cat commit_log.txt
-
-    - name: Commit version update
-      run: |
-        git config --local user.email "action@github.com"
-        git config --local user.name "GitHub Action"
-        git add ./user_service/version.txt
-        git commit -m "Bump version to ${{ steps.bump_version.outputs.new_version }}"
-
-    - name: Push changes
-      uses: ad-m/github-push-action@master
-      with:
-        github_token: ${{ secrets.GITHUB_TOKEN }}
-        branch: main
-
-    - name: Create Release
-      uses: softprops/action-gh-release@v1
-      with:
-        tag_name: user-service-v${{ steps.bump_version.outputs.new_version }}
-        name: User Service v${{ steps.bump_version.outputs.new_version }}
-        draft: false
-        prerelease: false
-      env:
-        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
-
-  deploy-api:
-    needs: [set-deployment-vars, update-version]
-    if: always() && (needs.update-version.result == 'success' || needs.update-version.result == 'skipped')
-    runs-on: ubuntu-latest
-    env:
-      DEPLOY_ENV: ${{ needs.set-deployment-vars.outputs.deploy_env }}
-      IMAGE_TAG: ${{ needs.set-deployment-vars.outputs.image_tag }}
-    steps:
-    - name: Checkout code
-      uses: actions/checkout@v3
-
-    - name: Configure AWS credentials
-      uses: aws-actions/configure-aws-credentials@v2
-      with:
-        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
-        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
-        aws-region: ${{ env.AWS_REGION }}
-
-    - name: Login to Amazon ECR
-      id: login-ecr
-      uses: aws-actions/amazon-ecr-login@v1
-
-    - name: Set additional deployment variables
-      run: |
-        echo "PORT_MAPPING=$([ "$DEPLOY_ENV" == "prod" ] && echo "8000:80" || echo "8001:80")" >> $GITHUB_ENV
-        
-        # Get EC2 Instance ID from SSM Parameter Store based on environment
-        EC2_INSTANCE_ID_PARAM="/$(echo $DEPLOY_ENV | tr '[:upper:]' '[:lower:]')/USER_EC2_INSTANCE_ID"
-        EC2_INSTANCE_ID=$(aws ssm get-parameter --name $EC2_INSTANCE_ID_PARAM --query "Parameter.Value" --output text)
-        echo "EC2_INSTANCE_ID=$EC2_INSTANCE_ID" >> $GITHUB_ENV
-
-    - name: Build, tag, and push API image to Amazon ECR
-      env:
-        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
-      run: |
-        set -e
-        docker compose --profile user-api build
-        docker image ls
-        docker tag user-api:latest $ECR_REGISTRY/$ECR_REPOSITORY_API:${{ env.IMAGE_TAG }}
-        docker push $ECR_REGISTRY/$ECR_REPOSITORY_API:${{ env.IMAGE_TAG }}
-
-    - name: Deploy to EC2
-      id: deploy-ec2
-      env:
-        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
-      run: |
-        set -e
-        echo "deployment_failed=false" >> $GITHUB_OUTPUT
-        echo "Deploying to EC2..."
-        DEPLOY_COMMAND_OUTPUT=$(aws ssm send-command \
-          --instance-ids "${{ env.EC2_INSTANCE_ID }}" \
-          --document-name "AWS-RunShellScript" \
-          --parameters '{
-            "commands": [
-              "set -e",
-              "aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ steps.login-ecr.outputs.registry }}",
-              "docker pull ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_API }}:${{ env.IMAGE_TAG }} >/dev/null",
-              "docker stop ${{ env.DEPLOY_ENV }}-app || true",
-              "docker rm ${{ env.DEPLOY_ENV }}-app || true",
-              "SSM_PARAMS_JSON=$(aws ssm get-parameters-by-path --path /${{ env.DEPLOY_ENV }}/ --with-decryption --query \"Parameters[*].{Name:Name,Value:Value}\" --output json)",
-              "ENV_VARS=$(echo \"$SSM_PARAMS_JSON\" | jq -r \".[] | \\\" -e \\\" + .Name + \\\"=\\\" + .Value\" | sed \"s/\\/[^\\/]*\\///g\" | tr \"\\n\" \" \")",
-              "POSTGRES_SECRET=$(aws secretsmanager get-secret-value --secret-id ${{ env.POSTGRES_PASSWORD_SECRET_NAME }} --query SecretString --output text)",
-              "POSTGRES_PASSWORD=$(echo $POSTGRES_SECRET | jq -r '.password')",
-              "SECRET_KEY_SECRET=$(aws secretsmanager get-secret-value --secret-id ${{ env.SECRET_KEY_SECRET_NAME }} --query SecretString --output text)",
-              "SECRET_KEY=$(echo $SECRET_KEY_SECRET | jq -r '.token')",
-              "S3_ACCESS_SECRET=$(aws secretsmanager get-secret-value --secret-id ${{ env.S3_ACCESS_CREDENTIALS_SECRET_NAME }} --query SecretString --output text)",
-              "S3_ACCESS_KEY=$(echo $S3_ACCESS_SECRET | jq -r '.access_key')",
-              "S3_SECRET_KEY=$(echo $S3_ACCESS_SECRET | jq -r '.secret_key')",
-              "echo \"Running database migrations...\"",
-              "echo \"Starting application...\"",
-              "docker run -d --name ${{ env.DEPLOY_ENV }}-app -p ${{ env.PORT_MAPPING }} -e ENVIRONMENT=${{ env.DEPLOY_ENV }} -e POSTGRES_PASSWORD=\"$POSTGRES_PASSWORD\" -e SECRET_KEY=\"$SECRET_KEY\" -e S3_ACCESS_KEY=\"$S3_ACCESS_KEY\" -e S3_SECRET_KEY=\"$S3_SECRET_KEY\" -e GOOGLE_IOS_CLIENT_ID=\"${{ secrets.GOOGLE_IOS_CLIENT_ID }}\" -e GOOGLE_ANDROID_CLIENT_ID=\"${{ secrets.GOOGLE_ANDROID_CLIENT_ID }}\" $ENV_VARS ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_API }}:${{ env.IMAGE_TAG }}",
-              "docker container prune -f",
-              "docker image prune -af",
-              "docker network prune -f",
-              "docker volume prune -af",
-              "echo ${{ env.DEPLOY_ENV }} deployment completed"
-            ]
-          }' \
-          --output json)
-        
-        DEPLOY_COMMAND_ID=$(echo "$DEPLOY_COMMAND_OUTPUT" | jq -r '.Command.CommandId')
-        
-        echo "Deployment command ID: $DEPLOY_COMMAND_ID"
-        
-        # Wait for the command to complete and check its status
-        while true; do
-          COMMAND_RESULT=$(aws ssm list-command-invocations \
-            --command-id "$DEPLOY_COMMAND_ID" \
-            --details \
-            --output json)
-          
-          STATUS=$(echo "$COMMAND_RESULT" | jq -r '.CommandInvocations[0].Status')
-          
-          if [ "$STATUS" = "Success" ]; then
-            echo "Deployment command executed successfully"
-            break
-          elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "TimedOut" ]; then
-            echo "Deployment command $STATUS"
-            echo "Command output:"
-            echo "$COMMAND_RESULT" | jq -r '.CommandInvocations[0].CommandPlugins[0].Output'
-            echo "deployment_failed=true" >> $GITHUB_OUTPUT
-            exit 1
-          fi
-          
-          echo "Waiting for deployment command to complete... Current status: $STATUS"
-          sleep 10
-        done
-
-    - name: Verify Deployment
-      id: verify-deployment
-      if: always()
-      run: |
-        set -e
-        echo "Verifying deployment..."
-        PORT="${{ env.DEPLOY_ENV == 'prod' && '8000' || '8001' }}"
-        MAX_RETRIES=5
-        RETRY_INTERVAL=10
-        
-        for i in $(seq 1 $MAX_RETRIES); do
-          echo "Attempt $i of $MAX_RETRIES"
-          HEALTH_CHECK_COMMAND_ID=$(aws ssm send-command \
-            --instance-ids "${{ env.EC2_INSTANCE_ID }}" \
-            --document-name "AWS-RunShellScript" \
-            --parameters "{\"commands\":[\"curl -s -o /dev/null -w \\\"%{http_code}\\\" http://localhost:$PORT/health\"]}" \
-            --output text \
-            --query "Command.CommandId")
-
-          sleep $RETRY_INTERVAL
-
-          HEALTH_CHECK_STATUS_CODE=$(aws ssm list-command-invocations \
-            --command-id "$HEALTH_CHECK_COMMAND_ID" \
-            --details \
-            --output text \
-            --query "CommandInvocations[].CommandPlugins[].Output")
-
-          if [ "$HEALTH_CHECK_STATUS_CODE" == "200" ]; then
-            echo "Deployment verified successfully"
-            echo "Updating stable tags..."
-            docker tag ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_API }}:${{ env.IMAGE_TAG }} ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_API }}:${{ env.DEPLOY_ENV }}-stable
-            docker push ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_API }}:${{ env.DEPLOY_ENV }}-stable
-            
-            echo "verification_status=success" >> $GITHUB_OUTPUT
-            echo "Deployment successful"
-            exit 0
-          fi
-
-          echo "Health check failed. Status code: $HEALTH_CHECK_STATUS_CODE"
-        done
-
-        echo "verification_status=failed" >> $GITHUB_OUTPUT
-        echo "Deployment verification failed after $MAX_RETRIES attempts"
-        exit 1
-
-    - name: Rollback Deployment
-      if: |
-        steps.deploy-ec2.outputs.deployment_failed == 'true' || 
-        steps.verify-deployment.outputs.verification_status == 'failed'
-      run: |
-        echo "Rolling back to previous stable version..."
-        aws ssm send-command \
-          --instance-ids "${{ env.EC2_INSTANCE_ID }}" \
-          --document-name "AWS-RunShellScript" \
-          --parameters '{
-            "commands": [
-              "docker stop ${{ env.DEPLOY_ENV }}-app || true",
-              "docker rm ${{ env.DEPLOY_ENV }}-app || true",
-              "docker rmi ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_API }}:${{ env.IMAGE_TAG }} || true",
-              "SSM_PARAMS_JSON=$(aws ssm get-parameters-by-path --path /${{ env.DEPLOY_ENV }}/ --with-decryption --query \"Parameters[*].{Name:Name,Value:Value}\" --output json)",
-              "ENV_VARS=$(echo \"$SSM_PARAMS_JSON\" | jq -r \".[] | \\\" -e \\\" + .Name + \\\"=\\\" + .Value\" | sed \"s/\\/[^\\/]*\\///g\" | tr \"\\n\" \" \")",
-              "POSTGRES_SECRET=$(aws secretsmanager get-secret-value --secret-id ${{ env.POSTGRES_PASSWORD_SECRET_NAME }} --query SecretString --output text)",
-              "POSTGRES_PASSWORD=$(echo $POSTGRES_SECRET | jq -r '.password')",
-              "SECRET_KEY_SECRET=$(aws secretsmanager get-secret-value --secret-id ${{ env.SECRET_KEY_SECRET_NAME }} --query SecretString --output text)",
-              "SECRET_KEY=$(echo $SECRET_KEY_SECRET | jq -r '.token')",
-              "docker run -d --name ${{ env.DEPLOY_ENV }}-app -p ${{ env.PORT_MAPPING }} -e ENVIRONMENT=${{ env.DEPLOY_ENV }} -e POSTGRES_PASSWORD=\"$POSTGRES_PASSWORD\" -e SECRET_KEY=\"$SECRET_KEY\" -e S3_ACCESS_KEY=\"$S3_ACCESS_KEY\" -e S3_SECRET_KEY=\"$S3_SECRET_KEY\" -e GOOGLE_IOS_CLIENT_ID=\"${{ secrets.GOOGLE_IOS_CLIENT_ID }}\" -e GOOGLE_ANDROID_CLIENT_ID=\"${{ secrets.GOOGLE_ANDROID_CLIENT_ID }}\" $ENV_VARS ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_API }}:${{ env.DEPLOY_ENV }}-stable"
-            ]
-          }'
diff --git a/.github/workflows/user_service_test.yml b/.github/workflows/user_service_test.yml
index 382c8c4..ec81790 100644
--- a/.github/workflows/user_service_test.yml
+++ b/.github/workflows/user_service_test.yml
@@ -12,12 +12,6 @@ on:
       - "user_service/**"
       - ".github/workflows/user_service_test.yml"
 
-env:
-  AWS_ACCESS_KEY_ID: minioadmin
-  AWS_SECRET_ACCESS_KEY: minioadmin
-  MINIO_CONSOLE_PORT: 9001
-  KMS_PORT: 9002
-
 jobs:
   lint:
     runs-on: ubuntu-latest
@@ -39,120 +33,11 @@ jobs:
     runs-on: ubuntu-latest
     steps:
       - uses: actions/checkout@v3
-
       - uses: actions/setup-go@v5
         with:
           go-version: "1.24"
           cache: true
           cache-dependency-path: user_service/go.sum
-
       - name: Build Lexicon Schema
         working-directory: user_service
         run: go run ./cmd/lexgen --build-file ./cmd/lexgen/build-config.json "./cmd/lexgen/lexicons/com/referendumapp"
-
-  test:
-    runs-on: ubuntu-latest
-    steps:
-      - uses: actions/checkout@v3
-
-      - uses: actions/setup-go@v5
-        with:
-          go-version: "1.24"
-          cache: true
-          cache-dependency-path: user_service/go.sum
-
-      - name: Set Go Cache Paths
-        id: go-cache-paths
-        run: |
-          echo "go-mod=$(go env GOMODCACHE)" >> $GITHUB_OUTPUT
-          echo "go-build=$(go env GOCACHE)" >> $GITHUB_OUTPUT
-
-      - name: Go Build Cache
-        uses: actions/cache@v3
-        with:
-          path: ${{ steps.go-cache-paths.outputs.go-build }}
-          key: ${{ runner.os }}-go-build-${{ hashFiles('**/go.sum') }}
-          restore-keys: |
-            ${{ runner.os }}-go-build-
-
-      - name: Pre-build Test Binary
-        working-directory: user_service
-        run: go test -c -tags=init,integration ./cmd/api/... ./internal/...
-
-      - name: Set up Docker Buildx
-        uses: docker/setup-buildx-action@v3
-
-      - name: Cache Migration Docker Layers
-        uses: actions/cache@v3
-        with:
-          path: /tmp/.buildx-cache-migrations
-          key: ${{ runner.os }}-buildx-migrations-${{ github.sha }}
-          restore-keys: |
-            ${{ runner.os }}-buildx-migrations-
-
-      - name: Cache User Test Docker Layers
-        uses: actions/cache@v3
-        with:
-          path: /tmp/.buildx-cache-user-tests
-          key: ${{ runner.os }}-buildx-user-tests-${{ github.sha }}
-          restore-keys: |
-            ${{ runner.os }}-buildx-user-tests-
-
-      - name: Build Migrations Image
-        uses: docker/build-push-action@v6
-        with:
-          context: ./data_service
-          file: ./data_service/Dockerfile
-          target: migrations
-          push: false
-          load: true
-          tags: migrations
-          cache-from: type=local,src=/tmp/.buildx-cache-migrations
-          cache-to: type=local,dest=/tmp/.buildx-cache-migrations-new,mode=max
-
-      - name: Build Test Image
-        uses: docker/build-push-action@v6
-        with:
-          context: ./user_service
-          file: ./user_service/Dockerfile
-          target: test
-          push: false
-          load: true
-          tags: user-test
-          build-args: |
-            GOMODCACHE=${{ steps.go-cache-paths.outputs.go-build }}
-            GOCACHE=${{ steps.go-cache-paths.outputs.go-mod }}
-          cache-from: type=local,src=/tmp/.buildx-cache-user-tests
-          cache-to: type=local,dest=/tmp/.buildx-cache-user-tests-new,mode=max
-
-      # TODO: Bug with `--add-host host.docker.internal:host-gateway`
-      # https://github.com/docker/buildx/issues/1832
-      - name: Run Tests
-        run: |
-          docker run \
-            --name user-test \
-            --env CI=true \
-            --env AWS_ACCESS_KEY_ID=${{ env.AWS_ACCESS_KEY_ID }} \
-            --env AWS_SECRET_ACCESS_KEY=${{ env.AWS_SECRET_ACCESS_KEY }} \
-            --env MINIO_CONSOLE_PORT=${{ env.MINIO_CONSOLE_PORT }} \
-            --env KMS_PORT=${{ env.KMS_PORT }} \
-            --env-file .env \
-            --volume /var/run/docker.sock:/var/run/docker.sock \
-            --rm \
-            user-test
-
-      - name: Update Cache
-        run: |
-          echo "Removing old cache directory if it exists..."
-          rm -rf /tmp/.buildx-cache-migrations || true
-          rm -rf /tmp/.buildx-cache-user-tests || true
-          
-          echo "Creating new merged cache directory..."
-          mv /tmp/.buildx-cache-migrations-new /tmp/.buildx-cache-migrations
-          mv /tmp/.buildx-cache-user-tests-new /tmp/.buildx-cache-user-tests
-
-      - name: Clean Tests
-        if: always()
-        run: |
-          docker container prune -f
-          docker volume prune -f
diff --git a/data_service/pyproject.toml b/data_service/pyproject.toml
index ee189ae..4e4a7dc 100644
--- a/data_service/pyproject.toml
+++ b/data_service/pyproject.toml
@@ -8,7 +8,7 @@ dynamic = ["version"]
 description = ""
 authors = [{name = "Makani Dalton", email = "makani@referendumapp.com"}]
 readme = "README.md"
-requires-python = ">=3.13.2"
+requires-python = ">=3.13.3"
 dependencies = [
     "alembic==1.15.2",
     "argon2-cffi==23.1.0",
diff --git a/docker-compose.yml b/docker-compose.yml
index 27e4ee4..e47dd9f 100644
--- a/docker-compose.yml
+++ b/docker-compose.yml
@@ -3,7 +3,6 @@ services:
     build:
       context: ./data_service
       target: api
-    image: api-base
     env_file: .env
     ports:
       - "80:80"
@@ -11,7 +10,6 @@ services:
 
   api:
     container_name: api
-    image: api
     extends:
       service: api-base
     command:
@@ -31,7 +29,6 @@ services:
 
   api-local:
     container_name: api-local
-    image: api-local
     extends:
       service: api-base
     build:
@@ -71,12 +68,10 @@ services:
   user-api-base:
     build:
       context: ./user_service
-      target: builder
+      target: base
       args:
         - GOCACHE=$GOCACHE
-        - GOMODCACHE=$GOMODCACHE
         - BINARY_PATH=$BINARY_PATH
-    image: user-api-base
     env_file: .env
     environment:
       - AWS_ACCESS_KEY_ID=$S3_ACCESS_KEY
@@ -85,7 +80,6 @@ services:
 
   user-api:
     container_name: user-api
-    image: user-api
     extends:
       service: user-api-base
     build:
@@ -93,16 +87,17 @@ services:
       target: user-prod
     ports:
       - "80:80"
-    profiles: ["user-api"]
+    profiles: ["atp"]
 
   user-api-local:
     container_name: user-api-local
-    image: user-api-local
     extends:
       service: user-api-base
     build:
       context: ./user_service
       target: user-local
+      args:
+        - GOMODCACHE=$GOMODCACHE
     environment:
       - CGO_ENABLED=0
     depends_on:
@@ -119,7 +114,6 @@ services:
       - ./user_service/go.sum:/code/go.sum
       - ./user_service/cmd:/code/cmd
       - ./user_service/internal:/code/internal
-      - ./user_service/pkg/common:/code/pkg/common
     ports:
       - "8080:80"
     healthcheck:
@@ -194,7 +188,7 @@ services:
       - KMS_REGION=$AWS_REGION
       - KMS_ACCOUNT_ID=$KMS_ACCOUNT_ID
     volumes:
-      - ./user_service/kms_seed.yaml:/init/seed.yaml
+      - ./user_service/kms_local/seed.yaml:/init/seed.yaml
     healthcheck:
       test:
         - "CMD"
@@ -211,14 +205,12 @@ services:
       interval: 2s
       timeout: 5s
       retries: 3
-    profiles: ["local-data", "local-empty"]
 
   local-db-init:
     container_name: local_db_init
     build:
       context: ./data_service
       target: local-db-init
-    image: local-db-init
     env_file: .env
     depends_on:
       db:
@@ -232,7 +224,6 @@ services:
     build:
       context: ./data_service
       target: migrations
-    image: migrations
     env_file: .env
     command: ["alembic", "upgrade", "head"]
     depends_on:
@@ -247,7 +238,6 @@ services:
     build:
       context: ./data_service
       target: pipeline
-    image: pipeline
     depends_on:
       db:
         condition: service_healthy
@@ -260,12 +250,11 @@ services:
     env_file: .env
     profiles: ["local-data"]
 
-  data-test:
+  test:
     container_name: test
     build:
       context: ./data_service
       target: test
-    image: data-test
     depends_on:
       db:
         condition: service_healthy
@@ -278,22 +267,6 @@ services:
     env_file: .env
     profiles: ["test"]
 
-  user-test:
-    container_name: user-test
-    image: user-test
-    extends:
-      service: user-api-base
-    build:
-      context: ./user_service
-      target: test
-    environment:
-      - AWS_ACCESS_KEY_ID=$S3_ACCESS_KEY
-      - AWS_SECRET_ACCESS_KEY=$S3_SECRET_KEY
-      - MINIO_CONSOLE_PORT=9001
-      - KMS_PORT=9002
-    volumes:
-      - /var/run/docker.sock:/var/run/docker.sock
-
 volumes:
   postgres_data:
   go-mod-cache:
diff --git a/user_service/Dockerfile b/user_service/Dockerfile
index b0d95a8..e30e9a8 100644
--- a/user_service/Dockerfile
+++ b/user_service/Dockerfile
@@ -1,11 +1,7 @@
-FROM golang:1.24-alpine AS base
+FROM golang:1.24-alpine as builder
 WORKDIR /code
 
-ARG GOCACHE
 ARG GOMODCACHE
-
-ENV CGO_ENABLED=0
-ENV GOCACHE=$GOCACHE
 ENV GOMODCACHE=$GOMODCACHE
 
 RUN --mount=type=cache,target=${GOMODCACHE} \
@@ -13,9 +9,12 @@ RUN --mount=type=cache,target=${GOMODCACHE} \
     --mount=type=bind,source=go.mod,target=go.mod \
     go mod download
 
-FROM base AS builder
 ARG BINARY_PATH
+ARG GOCACHE
+
 ENV BINARY_PATH=$BINARY_PATH
+ENV CGO_ENABLED=0
+ENV GOCACHE=$GOCACHE
 
 RUN --mount=type=cache,target=${GOMODCACHE} \
     --mount=type=cache,target=${GOCACHE} \
@@ -23,10 +22,9 @@ RUN --mount=type=cache,target=${GOMODCACHE} \
     --mount=type=bind,source=go.mod,target=go.mod \
     --mount=type=bind,source=./cmd/api/main.go,target=./cmd/api/main.go \
     --mount=type=bind,source=./internal,target=./internal \
-    --mount=type=bind,source=./pkg/common,target=./pkg/common \
     go build -o ${BINARY_PATH} ./cmd/api/main.go
 
-FROM alpine:latest AS user-prod
+FROM alpine:latest as user-prod
 ARG BINARY_PATH
 ENV BINARY_PATH=$BINARY_PATH
 
@@ -34,27 +32,8 @@ COPY --from=builder /code/${BINARY_PATH} ./app
 
 ENTRYPOINT ["./app"]
 
-FROM builder AS user-local
+FROM builder as user-local
 COPY cmd/dev cmd/dev
 RUN apk add --no-cache curl
 
 ENTRYPOINT ["go", "run", "-tags=dev", "./cmd/dev/main.go"]
-
-FROM base AS test-builder
-RUN --mount=type=cache,target=${GOMODCACHE} \
-    --mount=type=cache,target=${GOCACHE} \
-    --mount=type=bind,source=go.sum,target=go.sum \
-    --mount=type=bind,source=go.mod,target=go.mod \
-    --mount=type=bind,source=./cmd/api,target=./cmd/api \
-    --mount=type=bind,source=./internal,target=./internal \
-    --mount=type=bind,source=./pkg/common,target=./pkg/common \
-    --mount=type=bind,source=./testutil,target=./testutil \
-    go test -c -tags=init,integration ./... -o test/
-
-FROM alpine:latest AS test
-COPY --from=test-builder /code/test/ ./test/
-COPY go.mod go.mod
-COPY go.sum go.sum
-COPY kms_seed.yaml kms_seed.yaml
-
-CMD ["sh", "-c", "./test/api.test -test.v && ./test/service.test -test.v"]
diff --git a/user_service/cmd/api/initilization_test.go b/user_service/cmd/api/initilization_test.go
deleted file mode 100644
index 314be1a..0000000
--- a/user_service/cmd/api/initilization_test.go
+++ /dev/null
@@ -1,64 +0,0 @@
-//go:build init
-
-package main
-
-import (
-	"context"
-	"fmt"
-	"os"
-	"testing"
-	"time"
-
-	_ "github.com/lib/pq"
-	"github.com/referendumApp/referendumServices/internal/env-config"
-	"github.com/referendumApp/referendumServices/testutil"
-)
-
-func TestServiceInitialization(t *testing.T) {
-	ctx, cancel := context.WithCancel(context.Background())
-	defer cancel()
-
-	cfg, err := env.LoadConfig()
-	if err != nil {
-		t.Fatalf("Failed to load environment variables: %v", err)
-	}
-
-	docker, err := testutil.SetupDocker()
-	if err != nil {
-		t.Fatalf("Failed to setup docker API and network: %v", err)
-	}
-	defer docker.CleanupDocker()
-
-	pc, err := docker.SetupPostgres(ctx, cfg.DBConfig)
-	if err != nil {
-		t.Fatalf("Failed to setup postgres container: %v", err)
-	}
-	defer pc.CleanupPostgres(docker)
-
-	sc, err := docker.SetupS3(ctx)
-	if err != nil {
-		t.Fatalf("Failed to setup minio container: %v", err)
-	}
-	defer sc.CleanupS3(docker)
-
-	kms, err := docker.SetupKMS(ctx, cfg)
-	if err != nil {
-		t.Fatalf("Failed to setup kms container: %v", err)
-	}
-	defer kms.CleanupKMS(docker)
-
-	done := make(chan struct{})
-
-	go func() {
-		defer close(done)
-		if err := run(ctx, os.Stdout, cfg); err != nil {
-			t.Errorf("Failed to start server: %v", err)
-		}
-	}()
-	time.Sleep(1 * time.Second)
-
-	cancel()
-
-	<-done
-	fmt.Println("Server shutdown complete")
-}
diff --git a/user_service/cmd/api/main.go b/user_service/cmd/api/main.go
index 855ec78..017edb4 100644
--- a/user_service/cmd/api/main.go
+++ b/user_service/cmd/api/main.go
@@ -7,85 +7,42 @@ import (
 	"os"
 	"os/signal"
 	"syscall"
-	"time"
 
-	"github.com/referendumApp/referendumServices/internal/app"
-	"github.com/referendumApp/referendumServices/internal/aws"
-	"github.com/referendumApp/referendumServices/internal/car"
 	"github.com/referendumApp/referendumServices/internal/database"
 	"github.com/referendumApp/referendumServices/internal/env-config"
-	"github.com/referendumApp/referendumServices/internal/keymgr"
-	"github.com/referendumApp/referendumServices/internal/pds"
-	"github.com/referendumApp/referendumServices/internal/plc"
-	"github.com/referendumApp/referendumServices/internal/service"
+	"github.com/referendumApp/referendumServices/internal/server"
 	"github.com/referendumApp/referendumServices/internal/util"
 )
 
-func run(ctx context.Context, stdout io.Writer, cfg *env.Config) error {
+func run(ctx context.Context, stdout io.Writer) error {
 	// Marks the context as done when interrupt or SIGTERM signal is received
 	ctx, cancel := signal.NotifyContext(ctx, os.Interrupt, syscall.SIGINT, syscall.SIGTERM)
 	defer cancel()
 
-	logger := util.SetupLogger(ctx, stdout)
-
-	db, err := database.Connect(ctx, cfg.DBConfig, logger)
-	if err != nil {
-		return err
-	}
-	defer db.Close()
-
-	av := app.NewAppView(db, cfg.DBConfig.AtpDBSchema, cfg.HandleSuffix, logger)
-
-	clients, err := aws.NewClients(ctx, cfg.Env)
-	if err != nil {
-		return err
-	}
+	cfg := env.LoadConfigFromEnv()
 
-	pdsLogger := logger.WithGroup("pds")
-
-	cs, err := car.NewCarStore(ctx, db, clients.S3, cfg.DBConfig.CarDBSchema, cfg.Env, cfg.CarDir, pdsLogger)
-	if err != nil {
-		return err
-	}
+	logger := util.SetupLogger(ctx, stdout)
 
-	km, err := keymgr.NewKeyManager(
-		ctx,
-		clients.KMS,
-		clients.S3,
-		cfg.Env,
-		cfg.KeyDir,
-		cfg.RecoveryKey,
-		util.RefreshExpiry,
-		util.AccessExpiry-(5*time.Minute),
-		pdsLogger,
-	)
+	db, err := database.Connect(ctx, cfg, logger)
 	if err != nil {
 		return err
 	}
 
-	plc := plc.NewClient(cfg.PLCHost, km, pdsLogger)
-
-	pds, err := pds.NewPDS(ctx, km, plc, cs, cfg.HandleSuffix, cfg.ServiceUrl, cfg.SecretKey, logger)
+	srv, err := server.New(ctx, cfg, db, logger)
 	if err != nil {
 		return err
 	}
 
-	srv, err := service.New(ctx, av, pds, logger)
-	if err != nil {
+	if err := srv.Start(ctx); err != nil {
 		return err
 	}
 
-	return srv.Start(ctx)
+	return nil
 }
 
 func main() {
 	ctx := context.Background()
-	cfg, err := env.LoadConfig()
-	if err != nil {
-		log.Fatalf("Failed to load environment variables: %v", err)
-	}
-
-	if err := run(ctx, os.Stdout, cfg); err != nil {
+	if err := run(ctx, os.Stdout); err != nil {
 		log.Fatalf("Failed to start server: %v", err)
 	}
 }
diff --git a/user_service/cmd/cborgen/main.go b/user_service/cmd/cborgen/main.go
index 306ee01..34e1bd4 100644
--- a/user_service/cmd/cborgen/main.go
+++ b/user_service/cmd/cborgen/main.go
@@ -12,7 +12,7 @@ func main() {
 		MaxStringLength: 1_000_000,
 	}
 
-	if err := genCfg.WriteMapEncodersToFile("internal/plc/cbor_gen.go", "plc", plc.Op{}, plc.Service{}, plc.TombstoneOp{}); err != nil {
+	if err := genCfg.WriteMapEncodersToFile("internal/plc/cbor_gen.go", "plc", plc.CreateOp{}, plc.Service{}, plc.TombstoneOp{}); err != nil {
 		panic(err)
 	}
 
diff --git a/user_service/cmd/dev/main.go b/user_service/cmd/dev/main.go
index 919b4f8..a4ac339 100644
--- a/user_service/cmd/dev/main.go
+++ b/user_service/cmd/dev/main.go
@@ -3,6 +3,7 @@
 package main
 
 import (
+	"fmt"
 	"io/fs"
 	"log"
 	"os"
@@ -13,17 +14,16 @@ import (
 	"time"
 
 	"github.com/fsnotify/fsnotify"
-	"github.com/referendumApp/referendumServices/pkg/common"
 )
 
 var (
 	appPath          = "/cmd/api"
 	buildCmd         = "go"
 	buildArgs        = [4]string{"build", "-o"}
+	binaryName       = os.Getenv("BINARY_PATH")
 	debounceInterval = 50 * time.Millisecond
 	watchExts        = []string{".go"}
 	ignoreDirs       = []string{".github", ".vscode", "data_service"}
-	binaryName       string
 )
 
 func main() {
@@ -33,14 +33,10 @@ func main() {
 	}
 	defer watcher.Close()
 
-	projectRoot, err := common.FindProjectRoot()
+	projectRoot, err := findProjectRoot()
 	if err != nil {
 		log.Fatalf("Failed to find project Root: %v (%T)", err, err)
 	}
-	binaryName, err = common.GetEnvOrFail("BINARY_PATH")
-	if err != nil {
-		log.Fatalf("Failed to get binary name: %v", err)
-	}
 	binaryPath := filepath.Join(projectRoot, binaryName)
 	buildArgs[2] = binaryPath
 	buildArgs[3] = filepath.Join(projectRoot, appPath)
@@ -93,6 +89,26 @@ func main() {
 
 }
 
+func findProjectRoot() (string, error) {
+	dir, err := os.Getwd()
+	if err != nil {
+		return "", err
+	}
+
+	// Only return the directory if `go.mod` is found in the filepath
+	for {
+		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
+			return dir, nil
+		}
+
+		parent := filepath.Dir(dir)
+		if parent == dir {
+			return "", fmt.Errorf("could not find project root, no go.mod file found")
+		}
+		dir = parent
+	}
+}
+
 // Returns a callback function which only adds the relevant directories to the Watcher
 func watchDir(projectRoot string, watcher *fsnotify.Watcher) fs.WalkDirFunc {
 	return func(path string, d fs.DirEntry, err error) error {
diff --git a/user_service/cmd/lexgen/lexicons/com/referendumapp/legislator/profile.json b/user_service/cmd/lexgen/lexicons/com/referendumapp/legislator/profile.json
index 0073648..e5ad0fa 100644
--- a/user_service/cmd/lexgen/lexicons/com/referendumapp/legislator/profile.json
+++ b/user_service/cmd/lexgen/lexicons/com/referendumapp/legislator/profile.json
@@ -9,25 +9,28 @@
       "record": {
         "type": "object",
         "required": [
+          "legislatorId",
           "name",
           "district",
           "party",
-          "level",
-          "legislativeBody",
-          "state"
+          "role",
+          "state",
+          "legislature"
         ],
         "properties": {
+          "legislatorId": { "type": "integer" },
           "name": { "type": "string", "format": "name", "maxLength": 60 },
           "district": { "type": "string" },
           "party": { "type": "string" },
+          "role": { "type": "string" },
+          "state": { "type": "string" },
+          "legislature": { "type": "string" },
           "address": { "type": "string" },
           "facebook": { "type": "string" },
           "instagram": { "type": "string" },
           "twitter": { "type": "string" },
-          "level": { "type": "string", "enum": ["federal", "state", "local"] },
-          "legislativeBody": { "type": "string" },
-          "state": { "type": "string" },
           "phone": { "type": "string", "format": "e164" },
+          "followthemoneyEid": { "type": "string" },
           "imageUrl": { "type": "string" },
           "image": {
             "type": "blob",
diff --git a/user_service/cmd/lexgen/lexicons/com/referendumapp/server/createAccount.json b/user_service/cmd/lexgen/lexicons/com/referendumapp/server/createAccount.json
index eec1876..bc632d7 100644
--- a/user_service/cmd/lexgen/lexicons/com/referendumapp/server/createAccount.json
+++ b/user_service/cmd/lexgen/lexicons/com/referendumapp/server/createAccount.json
@@ -59,10 +59,10 @@
         "schema": {
           "type": "object",
           "description": "Account login session returned on successful account creation.",
-          "required": ["accessToken", "refreshToken", "handle", "displayName", "did", "tokenType"],
+          "required": ["accessToken", "refreshToken", "handle", "displayName", "did"],
           "properties": {
-            "accessToken": { "type": "string" },
-            "refreshToken": { "type": "string" },
+            "accessJwt": { "type": "string" },
+            "refreshJwt": { "type": "string" },
             "handle": {
               "type": "string",
               "format": "handle"
@@ -80,8 +80,7 @@
             "didDoc": {
               "type": "unknown",
               "description": "Complete DID document."
-            },
-            "tokenType": { "type": "string" }
+            }
           }
         }
       }
diff --git a/user_service/cmd/lexgen/lexicons/com/referendumapp/server/createLegislator.json b/user_service/cmd/lexgen/lexicons/com/referendumapp/server/createLegislator.json
new file mode 100644
index 0000000..5ef67ed
--- /dev/null
+++ b/user_service/cmd/lexgen/lexicons/com/referendumapp/server/createLegislator.json
@@ -0,0 +1,84 @@
+{
+    "lexicon": 1,
+    "id": "com.referendumapp.server.createLegislator",
+    "defs": {
+      "main": {
+        "type": "string",
+        "description": "Create a legislator. Implemented by PDS.",
+        "input": {
+          "encoding": "application/json",
+          "schema": {
+            "needsType": true,
+            "type": "object",
+            "required": ["legislatorId", "name", "district", "party", "role", "state", "legislature"],
+            "properties": {
+              "legislatorId": {
+                "type": "integer"
+              },
+              "name": {
+                "type": "string"
+              },
+              "district": {
+                "type": "string"
+              },
+              "party": {
+                "type": "string"
+              },
+              "role": {
+                "type": "string"
+              },
+              "state": {
+                "type": "string"
+              },
+              "legislature": {
+                "type": "string"
+              },
+              "address": {
+                "type": "string"
+              },
+              "facebook": {
+                "type": "string"
+              },
+              "instagram": {
+                "type": "string"
+              },
+              "twitter": {
+                "type": "string"
+              },
+              "phone": {
+                "type": "string",
+                "format": "e164"
+              },
+              "followthemoneyEid": {
+                "type": "string"
+              },
+              "imageUrl": {
+                "type": "string"
+              },
+              "image": {
+                  "type": "blob",
+                  "accept": ["image/png", "image/jpeg"],
+                  "maxSize": 1000000
+              }
+            }
+          }
+        },
+        "output": {
+          "encoding": "application/json",
+          "schema": {
+            "type": "object",
+            "description": "Confirmation returned on successful legislator creation.",
+            "required": ["did"],
+            "properties": {
+              "did": {
+                "type": "string",
+                "format": "did",
+                "description": "The DID of the new account."
+              }
+            }
+          }
+        }
+      }
+    }
+  }
+  
\ No newline at end of file
diff --git a/user_service/cmd/lexgen/main.go b/user_service/cmd/lexgen/main.go
index dff5ac9..4a4594d 100644
--- a/user_service/cmd/lexgen/main.go
+++ b/user_service/cmd/lexgen/main.go
@@ -9,7 +9,7 @@ import (
 	"path/filepath"
 	"strings"
 
-	lex "github.com/referendumApp/referendumServices/pkg/lexgen"
+	lex "github.com/referendumApp/referendumServices/lexgen"
 	cli "github.com/urfave/cli/v2"
 )
 
diff --git a/user_service/go.mod b/user_service/go.mod
index c610c5a..ba0ba18 100644
--- a/user_service/go.mod
+++ b/user_service/go.mod
@@ -26,10 +26,7 @@ require (
 	github.com/ipld/go-car/v2 v2.14.1
 	github.com/jackc/pgx/v5 v5.7.2
 	github.com/lib/pq v1.10.9
-	github.com/multiformats/go-multihash v0.2.3
-	github.com/ory/dockertest/v3 v3.12.0
 	github.com/prometheus/client_golang v1.21.1
-	github.com/stretchr/testify v1.10.0
 	github.com/urfave/cli/v2 v2.27.6
 	github.com/whyrusleeping/cbor-gen v0.3.1
 	github.com/whyrusleeping/go-did v0.0.0-20240828165449-bcaa7ae21371
@@ -42,10 +39,6 @@ require (
 )
 
 require (
-	dario.cat/mergo v1.0.0 // indirect
-	github.com/Azure/go-ansiterm v0.0.0-20230124172434-306776ec8161 // indirect
-	github.com/Microsoft/go-winio v0.6.2 // indirect
-	github.com/Nvveen/Gotty v0.0.0-20120604004816-cd527374f1e5 // indirect
 	github.com/awnumar/memcall v0.2.0 // indirect
 	github.com/aws/aws-sdk-go-v2 v1.36.3 // indirect
 	github.com/aws/aws-sdk-go-v2/aws/protocol/eventstream v1.6.10 // indirect
@@ -64,26 +57,17 @@ require (
 	github.com/aws/aws-sdk-go-v2/service/sts v1.33.19 // indirect
 	github.com/beorn7/perks v1.0.1 // indirect
 	github.com/carlmjohnson/versioninfo v0.22.5 // indirect
-	github.com/cenkalti/backoff/v4 v4.3.0 // indirect
 	github.com/cespare/xxhash/v2 v2.3.0 // indirect
-	github.com/containerd/continuity v0.4.5 // indirect
 	github.com/cpuguy83/go-md2man/v2 v2.0.5 // indirect
-	github.com/davecgh/go-spew v1.1.1 // indirect
 	github.com/decred/dcrd/dcrec/secp256k1/v4 v4.4.0 // indirect
-	github.com/docker/cli v27.4.1+incompatible // indirect
-	github.com/docker/docker v27.1.1+incompatible // indirect
-	github.com/docker/go-connections v0.5.0 // indirect
-	github.com/docker/go-units v0.5.0 // indirect
 	github.com/felixge/httpsnoop v1.0.4 // indirect
 	github.com/gabriel-vasile/mimetype v1.4.8 // indirect
 	github.com/go-logr/logr v1.4.2 // indirect
 	github.com/go-logr/stdr v1.2.2 // indirect
 	github.com/go-playground/locales v0.14.1 // indirect
 	github.com/go-playground/universal-translator v0.18.1 // indirect
-	github.com/go-viper/mapstructure/v2 v2.1.0 // indirect
 	github.com/goccy/go-json v0.10.2 // indirect
 	github.com/gogo/protobuf v1.3.2 // indirect
-	github.com/google/shlex v0.0.0-20191202100458-e7afc7fbc510 // indirect
 	github.com/google/uuid v1.6.0 // indirect
 	github.com/hashicorp/go-cleanhttp v0.5.2 // indirect
 	github.com/hashicorp/go-retryablehttp v0.7.7 // indirect
@@ -117,35 +101,24 @@ require (
 	github.com/lestrrat-go/option v1.0.1 // indirect
 	github.com/mattn/go-isatty v0.0.20 // indirect
 	github.com/minio/sha256-simd v1.0.1 // indirect
-	github.com/moby/docker-image-spec v1.3.1 // indirect
-	github.com/moby/sys/user v0.3.0 // indirect
-	github.com/moby/term v0.5.0 // indirect
 	github.com/mr-tron/base58 v1.2.0 // indirect
 	github.com/multiformats/go-base32 v0.1.0 // indirect
 	github.com/multiformats/go-base36 v0.2.0 // indirect
 	github.com/multiformats/go-multibase v0.2.0 // indirect
 	github.com/multiformats/go-multicodec v0.9.0 // indirect
+	github.com/multiformats/go-multihash v0.2.3 // indirect
 	github.com/multiformats/go-varint v0.0.7 // indirect
 	github.com/munnerz/goautoneg v0.0.0-20191010083416-a7dc8b61c822 // indirect
-	github.com/opencontainers/go-digest v1.0.0 // indirect
-	github.com/opencontainers/image-spec v1.1.0 // indirect
-	github.com/opencontainers/runc v1.2.3 // indirect
 	github.com/opentracing/opentracing-go v1.2.0 // indirect
 	github.com/petar/GoLLRB v0.0.0-20210522233825-ae3b015fd3e9 // indirect
-	github.com/pkg/errors v0.9.1 // indirect
-	github.com/pmezard/go-difflib v1.0.0 // indirect
 	github.com/polydawn/refmt v0.89.1-0.20221221234430-40501e09de1f // indirect
 	github.com/prometheus/client_model v0.6.1 // indirect
 	github.com/prometheus/common v0.62.0 // indirect
 	github.com/prometheus/procfs v0.15.1 // indirect
 	github.com/russross/blackfriday/v2 v2.1.0 // indirect
 	github.com/segmentio/asm v1.2.0 // indirect
-	github.com/sirupsen/logrus v1.9.3 // indirect
 	github.com/spaolacci/murmur3 v1.1.0 // indirect
 	github.com/whyrusleeping/cbor v0.0.0-20171005072247-63513f603b11 // indirect
-	github.com/xeipuuv/gojsonpointer v0.0.0-20190905194746-02993c407bfb // indirect
-	github.com/xeipuuv/gojsonreference v0.0.0-20180127040603-bd5ef7bd5415 // indirect
-	github.com/xeipuuv/gojsonschema v1.2.0 // indirect
 	github.com/xrash/smetrics v0.0.0-20240521201337-686a1a2994c1 // indirect
 	gitlab.com/yawning/tuplehash v0.0.0-20230713102510-df83abbf9a02 // indirect
 	go.opentelemetry.io/auto/sdk v1.1.0 // indirect
@@ -162,7 +135,5 @@ require (
 	golang.org/x/sys v0.32.0 // indirect
 	golang.org/x/text v0.24.0 // indirect
 	google.golang.org/protobuf v1.36.5 // indirect
-	gopkg.in/yaml.v2 v2.4.0 // indirect
-	gopkg.in/yaml.v3 v3.0.1 // indirect
 	lukechampine.com/blake3 v1.4.0 // indirect
 )
diff --git a/user_service/go.sum b/user_service/go.sum
index 9c42683..ce66f73 100644
--- a/user_service/go.sum
+++ b/user_service/go.sum
@@ -1,16 +1,6 @@
-dario.cat/mergo v1.0.0 h1:AGCNq9Evsj31mOgNPcLyXc+4PNABt905YmuqPYYpBWk=
-dario.cat/mergo v1.0.0/go.mod h1:uNxQE+84aUszobStD9th8a29P2fMDhsBdgRYvZOxGmk=
-filippo.io/edwards25519 v1.1.0 h1:FNf4tywRC1HmFuKW5xopWpigGjJKiJSV0Cqo0cJWDaA=
-filippo.io/edwards25519 v1.1.0/go.mod h1:BxyFTGdWcka3PhytdK4V28tE5sGfRvvvRV7EaN4VDT4=
-github.com/Azure/go-ansiterm v0.0.0-20230124172434-306776ec8161 h1:L/gRVlceqvL25UVaW/CKtUDjefjrs0SPonmDGUVOYP0=
-github.com/Azure/go-ansiterm v0.0.0-20230124172434-306776ec8161/go.mod h1:xomTg63KZ2rFqZQzSB4Vz2SUXa1BpHTVz9L5PTmPC4E=
 github.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=
 github.com/Masterminds/squirrel v1.5.4 h1:uUcX/aBc8O7Fg9kaISIUsHXdKuqehiXAMQTYX8afzqM=
 github.com/Masterminds/squirrel v1.5.4/go.mod h1:NNaOrjSoIDfDA40n7sr2tPNZRfjzjA400rg+riTZj10=
-github.com/Microsoft/go-winio v0.6.2 h1:F2VQgta7ecxGYO8k3ZZz3RS8fVIXVxONVUPlNERoyfY=
-github.com/Microsoft/go-winio v0.6.2/go.mod h1:yd8OoFMLzJbo9gZq8j5qaps8bJ9aShtEA8Ipt1oGCvU=
-github.com/Nvveen/Gotty v0.0.0-20120604004816-cd527374f1e5 h1:TngWCqHvy9oXAN6lEVMRuU21PR1EtLVZJmdB18Gu3Rw=
-github.com/Nvveen/Gotty v0.0.0-20120604004816-cd527374f1e5/go.mod h1:lmUJ/7eu/Q8D7ML55dXQrVaamCz2vxCfdQBasLZfHKk=
 github.com/RussellLuo/slidingwindow v0.0.0-20200528002341-535bb99d338b h1:5/++qT1/z812ZqBvqQt6ToRswSuPZ/B33m6xVHRzADU=
 github.com/RussellLuo/slidingwindow v0.0.0-20200528002341-535bb99d338b/go.mod h1:4+EPqMRApwwE/6yo6CxiHoSnBzjRr3jsqer7frxP8y4=
 github.com/awnumar/memcall v0.2.0 h1:sRaogqExTOOkkNwO9pzJsL8jrOV29UuUW7teRMfbqtI=
@@ -64,17 +54,11 @@ github.com/bluesky-social/indigo v0.0.0-20250318060234-4bd8faf4c988 h1:PjsF/jmCR
 github.com/bluesky-social/indigo v0.0.0-20250318060234-4bd8faf4c988/go.mod h1:NVBwZvbBSa93kfyweAmKwOLYawdVHdwZ9s+GZtBBVLA=
 github.com/carlmjohnson/versioninfo v0.22.5 h1:O00sjOLUAFxYQjlN/bzYTuZiS0y6fWDQjMRvwtKgwwc=
 github.com/carlmjohnson/versioninfo v0.22.5/go.mod h1:QT9mph3wcVfISUKd0i9sZfVrPviHuSF+cUtLjm2WSf8=
-github.com/cenkalti/backoff/v4 v4.3.0 h1:MyRJ/UdXutAwSAT+s3wNd7MfTIcy71VQueUuFK343L8=
-github.com/cenkalti/backoff/v4 v4.3.0/go.mod h1:Y3VNntkOUPxTVeUxJ/G5vcM//AlwfmyYozVcomhLiZE=
 github.com/cespare/xxhash/v2 v2.3.0 h1:UL815xU9SqsFlibzuggzjXhog7bL6oX9BbNZnL2UFvs=
 github.com/cespare/xxhash/v2 v2.3.0/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=
-github.com/containerd/continuity v0.4.5 h1:ZRoN1sXq9u7V6QoHMcVWGhOwDFqZ4B9i5H6un1Wh0x4=
-github.com/containerd/continuity v0.4.5/go.mod h1:/lNJvtJKUQStBzpVQ1+rasXO1LAWtUQssk28EZvJ3nE=
 github.com/cpuguy83/go-md2man/v2 v2.0.0-20190314233015-f79a8a8ca69d/go.mod h1:maD7wRr/U5Z6m/iR4s+kqSMx2CaBsrgA7czyZG/E6dU=
 github.com/cpuguy83/go-md2man/v2 v2.0.5 h1:ZtcqGrnekaHpVLArFSe4HK5DoKx1T0rq2DwVB0alcyc=
 github.com/cpuguy83/go-md2man/v2 v2.0.5/go.mod h1:tgQtvFlXSQOSOSIRvRPT7W67SCa46tRHOmNcaadrF8o=
-github.com/creack/pty v1.1.18 h1:n56/Zwd5o6whRC5PMGretI4IdRLlmBXYNjScPaBgsbY=
-github.com/creack/pty v1.1.18/go.mod h1:MOBLtS5ELjhRRrroQr9kyvTxUAFNvYEK993ew/Vr4O4=
 github.com/cskr/pubsub v1.0.2 h1:vlOzMhl6PFn60gRlTQQsIfVwaPB/B/8MziK8FhEPt/0=
 github.com/cskr/pubsub v1.0.2/go.mod h1:/8MzYXk/NJAz782G8RPkFzXTZVu63VotefPnR9TIRis=
 github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
@@ -82,14 +66,6 @@ github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c
 github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
 github.com/decred/dcrd/dcrec/secp256k1/v4 v4.4.0 h1:NMZiJj8QnKe1LgsbDayM4UoHwbvwDRwnI3hwNaAHRnc=
 github.com/decred/dcrd/dcrec/secp256k1/v4 v4.4.0/go.mod h1:ZXNYxsqcloTdSy/rNShjYzMhyjf0LaoftYK0p+A3h40=
-github.com/docker/cli v27.4.1+incompatible h1:VzPiUlRJ/xh+otB75gva3r05isHMo5wXDfPRi5/b4hI=
-github.com/docker/cli v27.4.1+incompatible/go.mod h1:JLrzqnKDaYBop7H2jaqPtU4hHvMKP+vjCwu2uszcLI8=
-github.com/docker/docker v27.1.1+incompatible h1:hO/M4MtV36kzKldqnA37IWhebRA+LnqqcqDja6kVaKY=
-github.com/docker/docker v27.1.1+incompatible/go.mod h1:eEKB0N0r5NX/I1kEveEz05bcu8tLC/8azJZsviup8Sk=
-github.com/docker/go-connections v0.5.0 h1:USnMq7hx7gwdVZq1L49hLXaFtUdTADjXGp+uj1Br63c=
-github.com/docker/go-connections v0.5.0/go.mod h1:ov60Kzw0kKElRwhNs9UlUHAE/F9Fe6GLaXnqyDdmEXc=
-github.com/docker/go-units v0.5.0 h1:69rxXcBk27SvSaaxTtLh/8llcHD8vYHT7WSdRZ/jvr4=
-github.com/docker/go-units v0.5.0/go.mod h1:fgPhTUdO+D/Jk86RDLlptpiXQzgHJF7gydDDbaIK4Dk=
 github.com/fatih/color v1.16.0 h1:zmkK9Ngbjj+K0yRhTVONQh1p/HknKYSlNT+vZCzyokM=
 github.com/fatih/color v1.16.0/go.mod h1:fL2Sau1YI5c0pdGEVCbKQbLXB6edEj1ZgiY4NijnWvE=
 github.com/felixge/httpsnoop v1.0.4 h1:NFTV2Zj1bL4mc9sqWACXbQFVBBg2W3GPvqp8/ESS2Wg=
@@ -117,10 +93,6 @@ github.com/go-playground/validator/v10 v10.26.0 h1:SP05Nqhjcvz81uJaRfEV0YBSSSGMc
 github.com/go-playground/validator/v10 v10.26.0/go.mod h1:I5QpIEbmr8On7W0TktmJAumgzX4CA1XNl4ZmDuVHKKo=
 github.com/go-redis/redis v6.15.9+incompatible h1:K0pv1D7EQUjfyoMql+r/jZqCLizCGKFlFgcHWWmHQjg=
 github.com/go-redis/redis v6.15.9+incompatible/go.mod h1:NAIEuMOZ/fxfXJIrKDQDz8wamY7mA7PouImQ2Jvg6kA=
-github.com/go-sql-driver/mysql v1.8.1 h1:LedoTUt/eveggdHS9qUFC1EFSa8bU2+1pZjSRpvNJ1Y=
-github.com/go-sql-driver/mysql v1.8.1/go.mod h1:wEBSXgmK//2ZFJyE+qWnIsVGmvmEKlqwuVSjsCm7DZg=
-github.com/go-viper/mapstructure/v2 v2.1.0 h1:gHnMa2Y/pIxElCH2GlZZ1lZSsn6XMtufpGyP1XxdC/w=
-github.com/go-viper/mapstructure/v2 v2.1.0/go.mod h1:oJDH3BJKyqBA2TXFhDsKDGDTlndYOZ6rGS0BRZIxGhM=
 github.com/go-yaml/yaml v2.1.0+incompatible/go.mod h1:w2MrLa16VYP0jy6N7M5kHaCkaLENm+P+Tv+MfurjSw0=
 github.com/goccy/go-json v0.10.2 h1:CrxCmQqYDkv1z7lO7Wbh2HN93uovUHgrECaO5ZrCXAU=
 github.com/goccy/go-json v0.10.2/go.mod h1:6MelG93GURQebXPDq3khkgXZkazVtN9CRI+MGFi0w8I=
@@ -133,8 +105,6 @@ github.com/google/go-cmp v0.7.0/go.mod h1:pXiqmnSA92OHEEa9HXL2W4E7lf9JzCmGVUdgjX
 github.com/google/gopacket v1.1.19 h1:ves8RnFZPGiFnTS0uPQStjwru6uO6h+nlr9j6fL7kF8=
 github.com/google/gopacket v1.1.19/go.mod h1:iJ8V8n6KS+z2U1A8pUwu8bW5SyEMkXJB8Yo/Vo+TKTo=
 github.com/google/renameio v0.1.0/go.mod h1:KWCgfxg9yswjAJkECMjeO8J8rahYeXnNhOm40UhjYkI=
-github.com/google/shlex v0.0.0-20191202100458-e7afc7fbc510 h1:El6M4kTTCOh6aBiKaUGG7oYTSPP8MxqL4YI3kZKwcP4=
-github.com/google/shlex v0.0.0-20191202100458-e7afc7fbc510/go.mod h1:pupxD2MaaD3pAXIBCelhxNneeOaAeabZDe5s4K6zSpQ=
 github.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=
 github.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
 github.com/gopherjs/gopherjs v0.0.0-20181017120253-0766667cb4d1/go.mod h1:wJfORRmW1u3UXTncJ5qlYoELFm8eSnnEO6hX4iZ3EWY=
@@ -297,12 +267,6 @@ github.com/miekg/dns v1.1.50 h1:DQUfb9uc6smULcREF09Uc+/Gd46YWqJd5DbpPE9xkcA=
 github.com/miekg/dns v1.1.50/go.mod h1:e3IlAVfNqAllflbibAZEWOXOQ+Ynzk/dDozDxY7XnME=
 github.com/minio/sha256-simd v1.0.1 h1:6kaan5IFmwTNynnKKpDHe6FWHohJOHhCPchzK49dzMM=
 github.com/minio/sha256-simd v1.0.1/go.mod h1:Pz6AKMiUdngCLpeTL/RJY1M9rUuPMYujV5xJjtbRSN8=
-github.com/moby/docker-image-spec v1.3.1 h1:jMKff3w6PgbfSa69GfNg+zN/XLhfXJGnEx3Nl2EsFP0=
-github.com/moby/docker-image-spec v1.3.1/go.mod h1:eKmb5VW8vQEh/BAr2yvVNvuiJuY6UIocYsFu/DxxRpo=
-github.com/moby/sys/user v0.3.0 h1:9ni5DlcW5an3SvRSx4MouotOygvzaXbaSrc/wGDFWPo=
-github.com/moby/sys/user v0.3.0/go.mod h1:bG+tYYYJgaMtRKgEmuueC0hJEAZWwtIbZTB+85uoHjs=
-github.com/moby/term v0.5.0 h1:xt8Q1nalod/v7BqbG21f8mQPqH+xAaC9C3N3wfWbVP0=
-github.com/moby/term v0.5.0/go.mod h1:8FzsFHVUBGZdbDsJw/ot+X+d5HLUbvklYLJ9uGfcI3Y=
 github.com/mr-tron/base58 v1.2.0 h1:T/HDJBh4ZCPbU39/+c3rRvE0uKBQlU27+QI8LJ4t64o=
 github.com/mr-tron/base58 v1.2.0/go.mod h1:BinMc/sQntlIE1frQmRFPUoPA1Zkr8VRgBdjWI2mNwc=
 github.com/multiformats/go-base32 v0.1.0 h1:pVx9xoSPqEIQG8o+UbAe7DNi51oej1NtK+aGkbLYxPE=
@@ -327,21 +291,11 @@ github.com/multiformats/go-varint v0.0.7 h1:sWSGR+f/eu5ABZA2ZpYKBILXTTs9JWpdEM/n
 github.com/multiformats/go-varint v0.0.7/go.mod h1:r8PUYw/fD/SjBCiKOoDlGF6QawOELpZAu9eioSos/OU=
 github.com/munnerz/goautoneg v0.0.0-20191010083416-a7dc8b61c822 h1:C3w9PqII01/Oq1c1nUAm88MOHcQC9l5mIlSMApZMrHA=
 github.com/munnerz/goautoneg v0.0.0-20191010083416-a7dc8b61c822/go.mod h1:+n7T8mK8HuQTcFwEeznm/DIxMOiR9yIdICNftLE1DvQ=
-github.com/opencontainers/go-digest v1.0.0 h1:apOUWs51W5PlhuyGyz9FCeeBIOUDA/6nW8Oi/yOhh5U=
-github.com/opencontainers/go-digest v1.0.0/go.mod h1:0JzlMkj0TRzQZfJkVvzbP0HBR3IKzErnv2BNG4W4MAM=
-github.com/opencontainers/image-spec v1.1.0 h1:8SG7/vwALn54lVB/0yZ/MMwhFrPYtpEHQb2IpWsCzug=
-github.com/opencontainers/image-spec v1.1.0/go.mod h1:W4s4sFTMaBeK1BQLXbG4AdM2szdn85PY75RI83NrTrM=
-github.com/opencontainers/runc v1.2.3 h1:fxE7amCzfZflJO2lHXf4y/y8M1BoAqp+FVmG19oYB80=
-github.com/opencontainers/runc v1.2.3/go.mod h1:nSxcWUydXrsBZVYNSkTjoQ/N6rcyTtn+1SD5D4+kRIM=
 github.com/opentracing/opentracing-go v1.2.0 h1:uEJPy/1a5RIPAJ0Ov+OIO8OxWu77jEv+1B0VhjKrZUs=
 github.com/opentracing/opentracing-go v1.2.0/go.mod h1:GxEUsuufX4nBwe+T+Wl9TAgYrxe9dPLANfrWvHYVTgc=
-github.com/ory/dockertest/v3 v3.12.0 h1:3oV9d0sDzlSQfHtIaB5k6ghUCVMVLpAY8hwrqoCyRCw=
-github.com/ory/dockertest/v3 v3.12.0/go.mod h1:aKNDTva3cp8dwOWwb9cWuX84aH5akkxXRvO7KCwWVjE=
 github.com/petar/GoLLRB v0.0.0-20210522233825-ae3b015fd3e9 h1:1/WtZae0yGtPq+TI6+Tv1WTxkukpXeMlviSxvL7SRgk=
 github.com/petar/GoLLRB v0.0.0-20210522233825-ae3b015fd3e9/go.mod h1:x3N5drFsm2uilKKuuYo6LdyD8vZAW55sH/9w+pbo1sw=
 github.com/pkg/errors v0.8.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
-github.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=
-github.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
 github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
 github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
 github.com/polydawn/refmt v0.89.1-0.20221221234430-40501e09de1f h1:VXTQfuJj9vKR4TCkEuWIckKvdHFeJH/huIFJ9/cXOB0=
@@ -363,8 +317,6 @@ github.com/russross/blackfriday/v2 v2.1.0/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQD
 github.com/segmentio/asm v1.2.0 h1:9BQrFxC+YOHJlTlHGkTrFWf59nbL3XnCoFLTwDCI7ys=
 github.com/segmentio/asm v1.2.0/go.mod h1:BqMnlJP91P8d+4ibuonYZw9mfnzI9HfxselHZr5aAcs=
 github.com/shurcooL/sanitized_anchor_name v1.0.0/go.mod h1:1NzhyTcUVG4SuEtjjoZeVRXNmyL/1OwPU0+IJeTBvfc=
-github.com/sirupsen/logrus v1.9.3 h1:dueUQJ1C2q9oE3F7wvmSGAaVtTmUizReu6fjN8uqzbQ=
-github.com/sirupsen/logrus v1.9.3/go.mod h1:naHLuLoDiP4jHNo9R0sCBMtWGeIprob74mVsIT4qYEQ=
 github.com/smartystreets/assertions v1.2.0 h1:42S6lae5dvLc7BrLu/0ugRtcFVjoJNMC/N3yZFZkDFs=
 github.com/smartystreets/assertions v1.2.0/go.mod h1:tcbTF8ujkAEcZ8TElKY+i30BzYlVhC/LOxJk7iOWnoo=
 github.com/smartystreets/goconvey v1.7.2 h1:9RBaZCeXEQ3UselpuwUQHltGVXvdwm6cv1hgR6gDIPg=
@@ -395,13 +347,6 @@ github.com/whyrusleeping/chunker v0.0.0-20181014151217-fe64bd25879f h1:jQa4QT2UP
 github.com/whyrusleeping/chunker v0.0.0-20181014151217-fe64bd25879f/go.mod h1:p9UJB6dDgdPgMJZs7UjUOdulKyRr9fqkS+6JKAInPy8=
 github.com/whyrusleeping/go-did v0.0.0-20240828165449-bcaa7ae21371 h1:W4jEGWdes35iuiiAYNZFOjx+dwzQOBh33kVpc0C0YiE=
 github.com/whyrusleeping/go-did v0.0.0-20240828165449-bcaa7ae21371/go.mod h1:39U9RRVr4CKbXpXYopWn+FSH5s+vWu6+RmguSPWAq5s=
-github.com/xeipuuv/gojsonpointer v0.0.0-20180127040702-4e3ac2762d5f/go.mod h1:N2zxlSyiKSe5eX1tZViRH5QA0qijqEDrYZiPEAiq3wU=
-github.com/xeipuuv/gojsonpointer v0.0.0-20190905194746-02993c407bfb h1:zGWFAtiMcyryUHoUjUJX0/lt1H2+i2Ka2n+D3DImSNo=
-github.com/xeipuuv/gojsonpointer v0.0.0-20190905194746-02993c407bfb/go.mod h1:N2zxlSyiKSe5eX1tZViRH5QA0qijqEDrYZiPEAiq3wU=
-github.com/xeipuuv/gojsonreference v0.0.0-20180127040603-bd5ef7bd5415 h1:EzJWgHovont7NscjpAxXsDA8S8BMYve8Y5+7cuRE7R0=
-github.com/xeipuuv/gojsonreference v0.0.0-20180127040603-bd5ef7bd5415/go.mod h1:GwrjFmJcFw6At/Gs6z4yjiIwzuJ1/+UwLxMQDVQXShQ=
-github.com/xeipuuv/gojsonschema v1.2.0 h1:LhYJRs+L4fBtjZUfuSZIKGeVu0QRy8e5Xi7D17UxZ74=
-github.com/xeipuuv/gojsonschema v1.2.0/go.mod h1:anYRn/JVcOK2ZgGU+IjEV4nwlhoK5sQluxsYJ78Id3Y=
 github.com/xrash/smetrics v0.0.0-20240521201337-686a1a2994c1 h1:gEOO8jv9F4OT7lGCjxCBTO/36wtF6j2nSip77qHd4x4=
 github.com/xrash/smetrics v0.0.0-20240521201337-686a1a2994c1/go.mod h1:Ohn+xnUBiLI6FVj/9LpzZWtj1/D6lUovWYBkxHVV3aM=
 github.com/yuin/goldmark v1.1.27/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
@@ -473,9 +418,7 @@ golang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7w
 golang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
 golang.org/x/sys v0.0.0-20210330210617-4fbd30eecc44/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
 golang.org/x/sys v0.0.0-20210510120138-977fb7262007/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
-golang.org/x/sys v0.0.0-20210616094352-59db8d763f22/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
 golang.org/x/sys v0.0.0-20210630005230-0f9fa26af87c/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
-golang.org/x/sys v0.0.0-20220715151400-c0bba94af5f8/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
 golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
 golang.org/x/sys v0.32.0 h1:s77OFDvIQeibCmezSnk/q6iAfkdiQaJi4VzroCFrN20=
 golang.org/x/sys v0.32.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=
@@ -519,8 +462,6 @@ gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C
 gopkg.in/yaml.v3 v3.0.0-20210107192922-496545a6307b/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
 gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
 gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
-gotest.tools/v3 v3.5.1 h1:EENdUnS3pdur5nybKYIh2Vfgc8IUNBjxDPSjtiJcOzU=
-gotest.tools/v3 v3.5.1/go.mod h1:isy3WKz7GK6uNw/sbHzfKBLvlvXwUyV06n6brMxxopU=
 honnef.co/go/tools v0.0.1-2019.2.3/go.mod h1:a3bituU0lyd329TUQxRnasdCoJDkEUEAqEt0JzvZhAg=
 lukechampine.com/blake3 v1.4.0 h1:xDbKOZCVbnZsfzM6mHSYcGRHZ3YrLDzqz8XnV4uaD5w=
 lukechampine.com/blake3 v1.4.0/go.mod h1:MQJNQCTnR+kwOP/JEZSxj3MaQjp80FOFSNMMHXcSeX0=
diff --git a/user_service/internal/app/identity.go b/user_service/internal/app/identity.go
index ac43e78..f4e48f3 100644
--- a/user_service/internal/app/identity.go
+++ b/user_service/internal/app/identity.go
@@ -4,6 +4,7 @@ import (
 	"context"
 	"database/sql"
 	"errors"
+	"fmt"
 	"strings"
 	"time"
 
@@ -34,6 +35,24 @@ func (v *View) validateHandle(ctx context.Context, handle string) *refErr.APIErr
 	return nil
 }
 
+func (v *View) validateLegislatorId(ctx context.Context, legislatorId int64) *refErr.APIError {
+	if legislatorId <= 0 {
+		fieldErr := refErr.FieldError{Field: "legislatorId", Message: "LegislatorId must be a positive integer"}
+		return fieldErr.Invalid()
+	}
+
+	filter := sq.Eq{"legislatorId": legislatorId}
+	if exists, err := v.meta.legislatorExists(ctx, filter); err != nil {
+		v.log.ErrorContext(ctx, "Error checking database for legislatorId", "error", err)
+		return refErr.InternalServer()
+	} else if exists {
+		fieldErr := refErr.FieldError{Field: "legislatorId", Message: "LegislatorId already exists"}
+		return fieldErr.Conflict()
+	}
+
+	return nil
+}
+
 // ResolveHandle validates handle, email, and password for create account request
 func (v *View) ResolveHandle(ctx context.Context, req *refApp.ServerCreateAccount_Input) (string, *refErr.APIError) {
 	if err := v.validateHandle(ctx, req.Handle); err != nil {
@@ -83,6 +102,28 @@ func (v *View) CreateUserAndPerson(ctx context.Context, user *atp.User, handle s
 	return nil
 }
 
+// ResolveLegislatorId validates legislatorId for create legislator request
+func (v *View) ResolveLegislatorHandle(ctx context.Context, req *refApp.ServerCreateLegislator_Input) (*string, *refErr.APIError) {
+	if err := v.validateLegislatorId(ctx, req.LegislatorId); err != nil {
+		v.log.ErrorContext(ctx, "Error validating legislatorId", "error", err)
+		return nil, err
+	}
+
+	filter := sq.Eq{"legislatorId": req.LegislatorId}
+	if exists, err := v.meta.legislatorExists(ctx, filter); err != nil {
+		v.log.ErrorContext(ctx, "Error checking database for legislatorId", "error", err)
+		return nil, refErr.InternalServer()
+	} else if exists {
+		nerr := errors.New("legislator already exists")
+		v.log.ErrorContext(ctx, nerr.Error(), "legislator", req.LegislatorId)
+		fieldErr := refErr.FieldError{Field: "legislatorId", Message: nerr.Error()}
+		return nil, fieldErr.Conflict()
+	}
+
+	handle := fmt.Sprintf("refLegislator%d", req.LegislatorId)
+	return &handle, nil
+}
+
 // AuthenticateUser validates username and password for a create session request
 func (v *View) AuthenticateUser(ctx context.Context, username string, pw string) (*atp.User, *refErr.APIError) {
 	defaultErr := refErr.FieldError{Message: "Email or password not found"}
@@ -124,14 +165,13 @@ func (v *View) AuthenticateSession(ctx context.Context, uid atp.Uid, did string)
 // DeleteAccount deletes a user and person record from the DB
 func (v *View) DeleteAccount(ctx context.Context, uid atp.Uid, did string) *refErr.APIError {
 	if err := v.meta.WithTransaction(ctx, func(ctx context.Context, tx pgx.Tx) error {
-		deletedAt := sql.NullTime{Time: time.Now(), Valid: true}
-
-		if err := v.meta.UpdateWithTx(ctx, tx, atp.User{DeletedAt: deletedAt}, sq.Eq{"id": uid}); err != nil {
+		updatedUser := atp.User{DeletedAt: sql.NullTime{Time: time.Now(), Valid: true}}
+		if err := v.meta.UpdateWithTx(ctx, tx, updatedUser, sq.Eq{"id": uid}); err != nil {
 			v.log.ErrorContext(ctx, "Failed to delete user", "error", err)
 			return err
 		}
 
-		person := atp.Person{Handle: sql.NullString{Valid: false}, Base: atp.Base{DeletedAt: deletedAt}}
+		person := atp.Person{Handle: sql.NullString{Valid: false}, Settings: &atp.Settings{Deleted: true}}
 		if err := v.meta.UpdateWithTx(ctx, tx, person, sq.Eq{"uid": uid}); err != nil {
 			v.log.ErrorContext(ctx, "Failed to delete person", "error", err)
 			return err
diff --git a/user_service/internal/app/meta.go b/user_service/internal/app/meta.go
index 65974db..376d6d3 100644
--- a/user_service/internal/app/meta.go
+++ b/user_service/internal/app/meta.go
@@ -104,6 +104,24 @@ func (vm *ViewMeta) userExists(ctx context.Context, filter sq.Eq) (bool, error)
 	return exists, err
 }
 
+func (vm *ViewMeta) legislatorExists(ctx context.Context, filter sq.Eq) (bool, error) {
+	var exists bool
+	innerSql, args, err := sq.Select("id").
+		From(vm.Schema + ".legislator").
+		Where(filter).
+		PlaceholderFormat(sq.Dollar).ToSql()
+
+	if err != nil {
+		vm.Log.InfoContext(ctx, "Error building legislator exists query", "error", err)
+		return false, err
+	}
+
+	sql := fmt.Sprintf("SELECT EXISTS(%s)", innerSql)
+
+	err = vm.DB.GetRow(ctx, sql, args...).Scan(&exists)
+	return exists, err
+}
+
 func (vm *ViewMeta) lookupUserQuery(ctx context.Context, filter sq.Sqlizer) (*atp.User, error) {
 	var entity atp.User
 	user, err := database.GetAll(ctx, vm.DB, entity, filter)
diff --git a/user_service/internal/app/view.go b/user_service/internal/app/view.go
index f8a279a..26ccd4d 100644
--- a/user_service/internal/app/view.go
+++ b/user_service/internal/app/view.go
@@ -4,6 +4,7 @@ import (
 	"log/slog"
 
 	"github.com/referendumApp/referendumServices/internal/database"
+	"github.com/referendumApp/referendumServices/internal/env-config"
 )
 
 // View struct containing dependencies for the app view
@@ -14,12 +15,12 @@ type View struct {
 }
 
 // NewAppView initializes a 'View' struct
-func NewAppView(db *database.DB, dbSchema string, handleSuffix string, logger *slog.Logger) *View {
-	avDb := db.WithSchema(dbSchema)
+func NewAppView(db *database.DB, cfg *env.Config, logger *slog.Logger) *View {
+	avDb := db.WithSchema(cfg.AtpDBSchema)
 	vm := &ViewMeta{avDb}
 	return &View{
 		meta:         vm,
-		handleSuffix: handleSuffix,
+		handleSuffix: cfg.HandleSuffix,
 		log:          logger.WithGroup("appview"),
 	}
 }
diff --git a/user_service/internal/aws/clients.go b/user_service/internal/aws/clients.go
index 83ec44c..628a9a4 100644
--- a/user_service/internal/aws/clients.go
+++ b/user_service/internal/aws/clients.go
@@ -35,7 +35,7 @@ func NewClients(ctx context.Context, env string) (*Clients, error) {
 
 	kmsClient := kms.NewFromConfig(cfg, func(o *kms.Options) {
 		if env == "local" {
-			log.Println("Configuring local KMS client")
+			log.Println("Configurating local KMS instance")
 			o.EndpointResolverV2 = &localKMSResolver{kmsHost: os.Getenv("KMS_HOST")}
 			o.HTTPClient = &http.Client{Transport: &kmsTransport{base: http.DefaultTransport}}
 		}
diff --git a/user_service/internal/car/store.go b/user_service/internal/car/store.go
index 0bc3bc6..aafa2f0 100644
--- a/user_service/internal/car/store.go
+++ b/user_service/internal/car/store.go
@@ -19,6 +19,7 @@ import (
 	car "github.com/ipld/go-car"
 	"github.com/referendumApp/referendumServices/internal/database"
 	"github.com/referendumApp/referendumServices/internal/domain/atp"
+	"github.com/referendumApp/referendumServices/internal/env-config"
 	cbg "github.com/whyrusleeping/cbor-gen"
 	"go.opentelemetry.io/otel"
 	"go.opentelemetry.io/otel/attribute"
@@ -58,19 +59,19 @@ type S3CarStore struct {
 // NewCarStore initializes a 'S3CarStore' struct
 func NewCarStore(
 	ctx context.Context,
+	cfg *env.Config,
 	db *database.DB,
 	client *s3.Client,
-	dbSchema, env, carDir string,
 	logger *slog.Logger,
 ) (Store, error) {
 	log.Println("Setting up CAR store")
 
-	carDb := db.WithSchema(dbSchema)
+	carDb := db.WithSchema(cfg.CarDBSchema)
 
-	if env == "local" {
-		if _, err := client.HeadBucket(ctx, &s3.HeadBucketInput{Bucket: &carDir}); err != nil {
-			log.Printf("The %s bucket does not exist, attempting to create bucket...\n", carDir)
-			if _, err := client.CreateBucket(ctx, &s3.CreateBucketInput{Bucket: &carDir}); err != nil {
+	if cfg.Environment == "local" {
+		if _, err := client.HeadBucket(ctx, &s3.HeadBucketInput{Bucket: &cfg.CarDir}); err != nil {
+			log.Printf("The %s bucket does not exist, attempting to create bucket...\n", cfg.CarDir)
+			if _, err := client.CreateBucket(ctx, &s3.CreateBucketInput{Bucket: &cfg.CarDir}); err != nil {
 				return nil, err
 			}
 			log.Println("Successfully created bucket!")
@@ -80,12 +81,12 @@ func NewCarStore(
 	meta := &StoreMeta{carDb}
 	out := &S3CarStore{
 		meta:    meta,
-		client:  &s3Client{client: client, bucket: carDir},
-		rootDir: carDir,
+		client:  &s3Client{client: client, bucket: cfg.CarDir},
+		rootDir: cfg.CarDir,
 		lastShardCache: lastShardCache{
 			source: meta,
 		},
-		log: logger.With("system", "carstore"),
+		log: logger.WithGroup("carstore"),
 	}
 	out.lastShardCache.init()
 
diff --git a/user_service/internal/database/database.go b/user_service/internal/database/database.go
index 2f69631..a96558b 100644
--- a/user_service/internal/database/database.go
+++ b/user_service/internal/database/database.go
@@ -19,7 +19,7 @@ type DB struct {
 }
 
 // Connect intializes a DB struct without a schema
-func Connect(ctx context.Context, cfg *env.DBConfig, logger *slog.Logger) (*DB, error) {
+func Connect(ctx context.Context, cfg *env.Config, logger *slog.Logger) (*DB, error) {
 	log.Println("Setting up database connection pool")
 
 	dbLogger := logger.WithGroup("db")
@@ -34,19 +34,14 @@ func Connect(ctx context.Context, cfg *env.DBConfig, logger *slog.Logger) (*DB,
 		cfg.DBName,
 	)
 
-	tmpConn, err := pgx.Connect(ctx, connStr)
+	conn, err := pgx.Connect(ctx, connStr)
 	if err != nil {
 		log.Printf("Failed to establish postgres connection: %s\n", connStr)
 		return nil, err
 	}
-	defer func() {
-		if connErr := tmpConn.Close(ctx); err != nil {
-			log.Printf("Error closing temporary DB connection: %v\n", connErr)
-		}
-	}()
 
 	// Ping the database to validate the connection
-	if pingErr := tmpConn.Ping(ctx); pingErr != nil {
+	if pingErr := conn.Ping(ctx); pingErr != nil {
 		log.Printf("Failed to ping database: %s\n", connStr)
 		return nil, pingErr
 	}
@@ -85,7 +80,6 @@ func (db *DB) WithSchema(schema string) *DB {
 
 func (db *DB) Close() {
 	if db.pool != nil {
-		log.Println("Closing database pool connections")
 		db.pool.Close()
 	}
 }
diff --git a/user_service/internal/domain/lexicon/referendumapp/cbor_gen.go b/user_service/internal/domain/lexicon/referendumapp/cbor_gen.go
index 2bb6b54..679b8fc 100644
--- a/user_service/internal/domain/lexicon/referendumapp/cbor_gen.go
+++ b/user_service/internal/domain/lexicon/referendumapp/cbor_gen.go
@@ -1662,7 +1662,7 @@ func (t *LegislatorProfile) MarshalCBOR(w io.Writer) error {
 	}
 
 	cw := cbg.NewCborWriter(w)
-	fieldCount := 14
+	fieldCount := 16
 
 	if t.Address == nil {
 		fieldCount--
@@ -1672,6 +1672,10 @@ func (t *LegislatorProfile) MarshalCBOR(w io.Writer) error {
 		fieldCount--
 	}
 
+	if t.FollowthemoneyEid == nil {
+		fieldCount--
+	}
+
 	if t.Image == nil {
 		fieldCount--
 	}
@@ -1719,6 +1723,29 @@ func (t *LegislatorProfile) MarshalCBOR(w io.Writer) error {
 		return err
 	}
 
+	// t.Role (string) (string)
+	if len("role") > 1000000 {
+		return xerrors.Errorf("Value in field \"role\" was too long")
+	}
+
+	if err := cw.WriteMajorTypeHeader(cbg.MajTextString, uint64(len("role"))); err != nil {
+		return err
+	}
+	if _, err := cw.WriteString(string("role")); err != nil {
+		return err
+	}
+
+	if len(t.Role) > 1000000 {
+		return xerrors.Errorf("Value in field t.Role was too long")
+	}
+
+	if err := cw.WriteMajorTypeHeader(cbg.MajTextString, uint64(len(t.Role))); err != nil {
+		return err
+	}
+	if _, err := cw.WriteString(string(t.Role)); err != nil {
+		return err
+	}
+
 	// t.LexiconTypeID (string) (string)
 	if len("$type") > 1000000 {
 		return xerrors.Errorf("Value in field \"$type\" was too long")
@@ -1757,29 +1784,6 @@ func (t *LegislatorProfile) MarshalCBOR(w io.Writer) error {
 		}
 	}
 
-	// t.Level (string) (string)
-	if len("level") > 1000000 {
-		return xerrors.Errorf("Value in field \"level\" was too long")
-	}
-
-	if err := cw.WriteMajorTypeHeader(cbg.MajTextString, uint64(len("level"))); err != nil {
-		return err
-	}
-	if _, err := cw.WriteString(string("level")); err != nil {
-		return err
-	}
-
-	if len(t.Level) > 1000000 {
-		return xerrors.Errorf("Value in field t.Level was too long")
-	}
-
-	if err := cw.WriteMajorTypeHeader(cbg.MajTextString, uint64(len(t.Level))); err != nil {
-		return err
-	}
-	if _, err := cw.WriteString(string(t.Level)); err != nil {
-		return err
-	}
-
 	// t.Party (string) (string)
 	if len("party") > 1000000 {
 		return xerrors.Errorf("Value in field \"party\" was too long")
@@ -2041,28 +2045,82 @@ func (t *LegislatorProfile) MarshalCBOR(w io.Writer) error {
 		}
 	}
 
-	// t.LegislativeBody (string) (string)
-	if len("legislativeBody") > 1000000 {
-		return xerrors.Errorf("Value in field \"legislativeBody\" was too long")
+	// t.Legislature (string) (string)
+	if len("legislature") > 1000000 {
+		return xerrors.Errorf("Value in field \"legislature\" was too long")
 	}
 
-	if err := cw.WriteMajorTypeHeader(cbg.MajTextString, uint64(len("legislativeBody"))); err != nil {
+	if err := cw.WriteMajorTypeHeader(cbg.MajTextString, uint64(len("legislature"))); err != nil {
 		return err
 	}
-	if _, err := cw.WriteString(string("legislativeBody")); err != nil {
+	if _, err := cw.WriteString(string("legislature")); err != nil {
 		return err
 	}
 
-	if len(t.LegislativeBody) > 1000000 {
-		return xerrors.Errorf("Value in field t.LegislativeBody was too long")
+	if len(t.Legislature) > 1000000 {
+		return xerrors.Errorf("Value in field t.Legislature was too long")
 	}
 
-	if err := cw.WriteMajorTypeHeader(cbg.MajTextString, uint64(len(t.LegislativeBody))); err != nil {
+	if err := cw.WriteMajorTypeHeader(cbg.MajTextString, uint64(len(t.Legislature))); err != nil {
 		return err
 	}
-	if _, err := cw.WriteString(string(t.LegislativeBody)); err != nil {
+	if _, err := cw.WriteString(string(t.Legislature)); err != nil {
 		return err
 	}
+
+	// t.LegislatorId (int64) (int64)
+	if len("legislatorId") > 1000000 {
+		return xerrors.Errorf("Value in field \"legislatorId\" was too long")
+	}
+
+	if err := cw.WriteMajorTypeHeader(cbg.MajTextString, uint64(len("legislatorId"))); err != nil {
+		return err
+	}
+	if _, err := cw.WriteString(string("legislatorId")); err != nil {
+		return err
+	}
+
+	if t.LegislatorId >= 0 {
+		if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.LegislatorId)); err != nil {
+			return err
+		}
+	} else {
+		if err := cw.WriteMajorTypeHeader(cbg.MajNegativeInt, uint64(-t.LegislatorId-1)); err != nil {
+			return err
+		}
+	}
+
+	// t.FollowthemoneyEid (string) (string)
+	if t.FollowthemoneyEid != nil {
+
+		if len("followthemoneyEid") > 1000000 {
+			return xerrors.Errorf("Value in field \"followthemoneyEid\" was too long")
+		}
+
+		if err := cw.WriteMajorTypeHeader(cbg.MajTextString, uint64(len("followthemoneyEid"))); err != nil {
+			return err
+		}
+		if _, err := cw.WriteString(string("followthemoneyEid")); err != nil {
+			return err
+		}
+
+		if t.FollowthemoneyEid == nil {
+			if _, err := cw.Write(cbg.CborNull); err != nil {
+				return err
+			}
+		} else {
+			if len(*t.FollowthemoneyEid) > 1000000 {
+				return xerrors.Errorf("Value in field t.FollowthemoneyEid was too long")
+			}
+
+			if err := cw.WriteMajorTypeHeader(cbg.MajTextString, uint64(len(*t.FollowthemoneyEid))); err != nil {
+				return err
+			}
+			if _, err := cw.WriteString(string(*t.FollowthemoneyEid)); err != nil {
+				return err
+			}
+		}
+	}
 	return nil
 }
 
@@ -2091,7 +2149,7 @@ func (t *LegislatorProfile) UnmarshalCBOR(r io.Reader) (err error) {
 
 	n := extra
 
-	nameBuf := make([]byte, 15)
+	nameBuf := make([]byte, 17)
 	for i := uint64(0); i < n; i++ {
 		nameLen, ok, err := cbg.ReadFullStringIntoBuf(cr, nameBuf, 1000000)
 		if err != nil {
@@ -2118,6 +2176,17 @@ func (t *LegislatorProfile) UnmarshalCBOR(r io.Reader) (err error) {
 
 				t.Name = string(sval)
 			}
+			// t.Role (string) (string)
+		case "role":
+
+			{
+				sval, err := cbg.ReadStringWithMax(cr, 1000000)
+				if err != nil {
+					return err
+				}
+
+				t.Role = string(sval)
+			}
 			// t.LexiconTypeID (string) (string)
 		case "$type":
 
@@ -2149,17 +2218,6 @@ func (t *LegislatorProfile) UnmarshalCBOR(r io.Reader) (err error) {
 				}
 
 			}
-			// t.Level (string) (string)
-		case "level":
-
-			{
-				sval, err := cbg.ReadStringWithMax(cr, 1000000)
-				if err != nil {
-					return err
-				}
-
-				t.Level = string(sval)
-			}
 			// t.Party (string) (string)
 		case "party":
 
@@ -2319,8 +2377,8 @@ func (t *LegislatorProfile) UnmarshalCBOR(r io.Reader) (err error) {
 					t.Instagram = (*string)(&sval)
 				}
 			}
-			// t.LegislativeBody (string) (string)
-		case "legislativeBody":
+			// t.Legislature (string) (string)
+		case "legislature":
 
 			{
 				sval, err := cbg.ReadStringWithMax(cr, 1000000)
@@ -2328,7 +2386,54 @@ func (t *LegislatorProfile) UnmarshalCBOR(r io.Reader) (err error) {
 					return err
 				}
 
-				t.LegislativeBody = string(sval)
+				t.Legislature = string(sval)
+			}
+			// t.LegislatorId (int64) (int64)
+		case "legislatorId":
+			{
+				maj, extra, err := cr.ReadHeader()
+				if err != nil {
+					return err
+				}
+				var extraI int64
+				switch maj {
+				case cbg.MajUnsignedInt:
+					extraI = int64(extra)
+					if extraI < 0 {
+						return fmt.Errorf("int64 positive overflow")
+					}
+				case cbg.MajNegativeInt:
+					extraI = int64(extra)
+					if extraI < 0 {
+						return fmt.Errorf("int64 negative overflow")
+					}
+					extraI = -1 - extraI
+				default:
+					return fmt.Errorf("wrong type for int64 field: %d", maj)
+				}
+
+				t.LegislatorId = int64(extraI)
+			}
+			// t.FollowthemoneyEid (string) (string)
+		case "followthemoneyEid":
+
+			{
+				b, err := cr.ReadByte()
+				if err != nil {
+					return err
+				}
+				if b != cbg.CborNull[0] {
+					if err := cr.UnreadByte(); err != nil {
+						return err
+					}
+
+					sval, err := cbg.ReadStringWithMax(cr, 1000000)
+					if err != nil {
+						return err
+					}
+
+					t.FollowthemoneyEid = (*string)(&sval)
+				}
 			}
 
 		default:
diff --git a/user_service/internal/domain/lexicon/referendumapp/legislatorProfile.go b/user_service/internal/domain/lexicon/referendumapp/legislatorProfile.go
index 1732c72..0e32f54 100644
--- a/user_service/internal/domain/lexicon/referendumapp/legislatorProfile.go
+++ b/user_service/internal/domain/lexicon/referendumapp/legislatorProfile.go
@@ -14,20 +14,22 @@ func init() {
 
 // RECORDTYPE: LegislatorProfile
 type LegislatorProfile struct {
-	LexiconTypeID   string        `json:"$type" cborgen:"$type,const=com.referendumapp.legislator.profile" validate:"required"`
-	Address         *string       `json:"address,omitempty" cborgen:"address,omitempty" validate:"omitempty"`
-	District        string        `json:"district" cborgen:"district" validate:"required"`
-	Facebook        *string       `json:"facebook,omitempty" cborgen:"facebook,omitempty" validate:"omitempty"`
-	Image           *util.LexBlob `json:"image,omitempty" cborgen:"image,omitempty" validate:"omitempty"`
-	ImageUrl        *string       `json:"imageUrl,omitempty" cborgen:"imageUrl,omitempty" validate:"omitempty"`
-	Instagram       *string       `json:"instagram,omitempty" cborgen:"instagram,omitempty" validate:"omitempty"`
-	LegislativeBody string        `json:"legislativeBody" cborgen:"legislativeBody" validate:"required"`
-	Level           string        `json:"level" cborgen:"level" validate:"required,oneof=federal,oneof=state,oneof=local"`
-	Name            string        `json:"name" cborgen:"name" validate:"required,name,max=60"`
-	Party           string        `json:"party" cborgen:"party" validate:"required"`
-	Phone           *string       `json:"phone,omitempty" cborgen:"phone,omitempty" validate:"omitempty,e164"`
-	State           string        `json:"state" cborgen:"state" validate:"required"`
-	Twitter         *string       `json:"twitter,omitempty" cborgen:"twitter,omitempty" validate:"omitempty"`
+	LexiconTypeID     string        `json:"$type" cborgen:"$type,const=com.referendumapp.legislator.profile" validate:"required"`
+	Address           *string       `json:"address,omitempty" cborgen:"address,omitempty" validate:"omitempty"`
+	District          string        `json:"district" cborgen:"district" validate:"required"`
+	Facebook          *string       `json:"facebook,omitempty" cborgen:"facebook,omitempty" validate:"omitempty"`
+	FollowthemoneyEid *string       `json:"followthemoneyEid,omitempty" cborgen:"followthemoneyEid,omitempty" validate:"omitempty"`
+	Image             *util.LexBlob `json:"image,omitempty" cborgen:"image,omitempty" validate:"omitempty"`
+	ImageUrl          *string       `json:"imageUrl,omitempty" cborgen:"imageUrl,omitempty" validate:"omitempty"`
+	Instagram         *string       `json:"instagram,omitempty" cborgen:"instagram,omitempty" validate:"omitempty"`
+	LegislatorId      int64         `json:"legislatorId" cborgen:"legislatorId" validate:"required"`
+	Legislature       string        `json:"legislature" cborgen:"legislature" validate:"required"`
+	Name              string        `json:"name" cborgen:"name" validate:"required,name,max=60"`
+	Party             string        `json:"party" cborgen:"party" validate:"required"`
+	Phone             *string       `json:"phone,omitempty" cborgen:"phone,omitempty" validate:"omitempty,e164"`
+	Role              string        `json:"role" cborgen:"role" validate:"required"`
+	State             string        `json:"state" cborgen:"state" validate:"required"`
+	Twitter           *string       `json:"twitter,omitempty" cborgen:"twitter,omitempty" validate:"omitempty"`
 }
 
 func (t LegislatorProfile) NSID() string {
diff --git a/user_service/internal/domain/lexicon/referendumapp/serverCreateAccount.go b/user_service/internal/domain/lexicon/referendumapp/serverCreateAccount.go
index cd19308..97ac48b 100644
--- a/user_service/internal/domain/lexicon/referendumapp/serverCreateAccount.go
+++ b/user_service/internal/domain/lexicon/referendumapp/serverCreateAccount.go
@@ -25,13 +25,12 @@ type ServerCreateAccount_Input struct {
 //
 // Account login session returned on successful account creation.
 type ServerCreateAccount_Output struct {
-	AccessToken string `json:"accessToken" cborgen:"accessToken" validate:"required"`
+	AccessJwt *string `json:"accessJwt,omitempty" cborgen:"accessJwt,omitempty" validate:"omitempty"`
 	// did: The DID of the new account.
 	Did string `json:"did" cborgen:"did" validate:"required,did"`
 	// didDoc: Complete DID document.
-	DidDoc       *interface{} `json:"didDoc,omitempty" cborgen:"didDoc,omitempty" validate:"omitempty"`
-	DisplayName  string       `json:"displayName" cborgen:"displayName" validate:"required,name,max=60"`
-	Handle       string       `json:"handle" cborgen:"handle" validate:"required,handle"`
-	RefreshToken string       `json:"refreshToken" cborgen:"refreshToken" validate:"required"`
-	TokenType    string       `json:"tokenType" cborgen:"tokenType" validate:"required"`
+	DidDoc      *interface{} `json:"didDoc,omitempty" cborgen:"didDoc,omitempty" validate:"omitempty"`
+	DisplayName string       `json:"displayName" cborgen:"displayName" validate:"required,name,max=60"`
+	Handle      string       `json:"handle" cborgen:"handle" validate:"required,handle"`
+	RefreshJwt  *string      `json:"refreshJwt,omitempty" cborgen:"refreshJwt,omitempty" validate:"omitempty"`
 }
diff --git a/user_service/internal/domain/lexicon/referendumapp/serverCreateLegislator.go b/user_service/internal/domain/lexicon/referendumapp/serverCreateLegislator.go
new file mode 100644
index 0000000..1287ad0
--- /dev/null
+++ b/user_service/internal/domain/lexicon/referendumapp/serverCreateLegislator.go
@@ -0,0 +1,36 @@
+// Code generated by cmd/lexgen (see Makefile's lexgen); DO NOT EDIT.
+
+package referendumapp
+
+// schema: com.referendumapp.server.createLegislator
+
+import (
+	"github.com/bluesky-social/indigo/lex/util"
+)
+
+// ServerCreateLegislator_Input is the input argument to a com.referendumapp.server.createLegislator call.
+type ServerCreateLegislator_Input struct {
+	Address           *string       `json:"address,omitempty" cborgen:"address,omitempty" validate:"omitempty"`
+	District          string        `json:"district" cborgen:"district" validate:"required"`
+	Facebook          *string       `json:"facebook,omitempty" cborgen:"facebook,omitempty" validate:"omitempty"`
+	FollowthemoneyEid *string       `json:"followthemoneyEid,omitempty" cborgen:"followthemoneyEid,omitempty" validate:"omitempty"`
+	Image             *util.LexBlob `json:"image,omitempty" cborgen:"image,omitempty" validate:"omitempty"`
+	ImageUrl          *string       `json:"imageUrl,omitempty" cborgen:"imageUrl,omitempty" validate:"omitempty"`
+	Instagram         *string       `json:"instagram,omitempty" cborgen:"instagram,omitempty" validate:"omitempty"`
+	LegislatorId      int64         `json:"legislatorId" cborgen:"legislatorId" validate:"required"`
+	Legislature       string        `json:"legislature" cborgen:"legislature" validate:"required"`
+	Name              string        `json:"name" cborgen:"name" validate:"required"`
+	Party             string        `json:"party" cborgen:"party" validate:"required"`
+	Phone             *string       `json:"phone,omitempty" cborgen:"phone,omitempty" validate:"omitempty,e164"`
+	Role              string        `json:"role" cborgen:"role" validate:"required"`
+	State             string        `json:"state" cborgen:"state" validate:"required"`
+	Twitter           *string       `json:"twitter,omitempty" cborgen:"twitter,omitempty" validate:"omitempty"`
+}
+
+// ServerCreateLegislator_Output is the output of a com.referendumapp.server.createLegislator call.
+//
+// Confirmation returned on successful legislator creation.
+type ServerCreateLegislator_Output struct {
+	// did: The DID of the new account.
+	Did string `json:"did" cborgen:"did" validate:"required,did"`
+}
diff --git a/user_service/internal/env-config/config.go b/user_service/internal/env-config/config.go
new file mode 100644
index 0000000..b79c8a2
--- /dev/null
+++ b/user_service/internal/env-config/config.go
@@ -0,0 +1,97 @@
+// Contains all environment variables required for initializing the service
+
+package env
+
+import (
+	"log"
+	"os"
+	"strconv"
+	"time"
+)
+
+func getEnvOrFail(key string) string {
+	val := os.Getenv(key)
+	if val == "" {
+		log.Fatalf("Missing required environment variable: %s", key)
+	}
+
+	return val
+}
+
+func getIntEnv(key string) int {
+	val := getEnvOrFail(key)
+
+	valInt, err := strconv.Atoi(val)
+	if err != nil {
+		log.Fatalf("Failed to convert %s environment variable to int: %v", key, err)
+	}
+
+	return valInt
+}
+
+// Config contains all required environment variables
+type Config struct {
+	Environment  string
+	PgUser       string
+	PgPassword   string
+	PgHost       string
+	PgPort       string
+	DBName       string
+	AtpDBSchema  string
+	HandleSuffix string
+	ServiceUrl   string
+	RecoveryKey  string
+	KeyDir       string
+	CarDir       string
+	CarDBSchema  string
+	PLCHost      string
+	SecretKey    []byte
+	MaxConnLife  time.Duration // Maximum connection lifetime
+	MaxConnIdle  time.Duration // Maximum connection idle time}
+	CarMaxConns  int
+	MaxConns     int32 // Maximum number of connections in the pool
+	MinConns     int32 // Minimum number of connections in the pool
+}
+
+// LoadConfigFromEnv initializes 'Config' struct
+func LoadConfigFromEnv() *Config {
+	log.Println("Loading runtime env vars")
+
+	config := Config{
+		Environment: getEnvOrFail("ENVIRONMENT"),
+		// Database
+		PgUser:     getEnvOrFail("POSTGRES_USER"),
+		PgPassword: getEnvOrFail("POSTGRES_PASSWORD"),
+		PgHost:     getEnvOrFail("POSTGRES_HOST"),
+		PgPort:     getEnvOrFail("POSTGRES_PORT"),
+		DBName:     getEnvOrFail("REFERENDUM_DB_NAME"),
+
+		// Database pool settings
+		MaxConns:    10,
+		MinConns:    2,
+		MaxConnLife: time.Hour,
+		MaxConnIdle: time.Minute * 30,
+
+		// Server
+		SecretKey: []byte(getEnvOrFail("SECRET_KEY")),
+
+		// ATP
+		HandleSuffix: getEnvOrFail("HANDLE_SUFFIX"),
+		ServiceUrl:   getEnvOrFail("USER_SERVICE_URL"),
+		AtpDBSchema:  getEnvOrFail("ATP_DB_SCHEMA"),
+		RecoveryKey:  getEnvOrFail("PDS_RECOVERY_DID_KEY"),
+		KeyDir:       getEnvOrFail("KEYSTORE_DIR"),
+
+		// Carstore
+		CarDir:      getEnvOrFail("CARSTORE_DIR"),
+		CarDBSchema: getEnvOrFail("CARSTORE_DB_SCHEMA"),
+		CarMaxConns: getIntEnv("MAX_CARSTORE_CONNECTIONS"),
+
+		// PLC
+		PLCHost: getEnvOrFail("PLC_HOST"),
+	}
+
+	log.Println("Successfully loaded env vars!")
+
+	return &config
+}
diff --git a/user_service/internal/env-config/env.go b/user_service/internal/env-config/env.go
deleted file mode 100644
index e3f4c7c..0000000
--- a/user_service/internal/env-config/env.go
+++ /dev/null
@@ -1,148 +0,0 @@
-// Contains all environment variables required for initializing the service
-
-package env
-
-import (
-	"log"
-	"time"
-
-	"github.com/referendumApp/referendumServices/pkg/common"
-)
-
-type DBConfig struct {
-	PgUser      string
-	PgPassword  string
-	PgHost      string
-	PgPort      string
-	DBName      string
-	AtpDBSchema string
-	CarDBSchema string
-	MaxConnLife time.Duration // Maximum connection lifetime
-	MaxConnIdle time.Duration // Maximum connection idle time}
-	MaxConns    int32         // Maximum number of connections in the pool
-	MinConns    int32         // Minimum number of connections in the pool
-}
-
-// Config contains all required environment variables
-type Config struct {
-	DBConfig     *DBConfig
-	Env          string
-	HandleSuffix string
-	ServiceUrl   string
-	RecoveryKey  string
-	KeyDir       string
-	CarDir       string
-	PLCHost      string
-	SecretKey    []byte
-	CarMaxConns  int
-}
-
-// LoadConfig initializes 'Config' struct
-func LoadConfig() (*Config, error) {
-	log.Println("Loading runtime env vars")
-
-	dbUser, err := common.GetEnvOrFail("POSTGRES_USER")
-	if err != nil {
-		return nil, err
-	}
-	dbPw, err := common.GetEnvOrFail("POSTGRES_PASSWORD")
-	if err != nil {
-		return nil, err
-	}
-	dbHost, err := common.GetEnvOrFail("POSTGRES_HOST")
-	if err != nil {
-		return nil, err
-	}
-	dbPort, err := common.GetEnvOrFail("POSTGRES_PORT")
-	if err != nil {
-		return nil, err
-	}
-	dbName, err := common.GetEnvOrFail("REFERENDUM_DB_NAME")
-	if err != nil {
-		return nil, err
-	}
-	atpSchema, err := common.GetEnvOrFail("ATP_DB_SCHEMA")
-	if err != nil {
-		return nil, err
-	}
-	carSchema, err := common.GetEnvOrFail("CARSTORE_DB_SCHEMA")
-	if err != nil {
-		return nil, err
-	}
-
-	dbConfig := &DBConfig{
-		PgUser:      dbUser,
-		PgPassword:  dbPw,
-		PgHost:      dbHost,
-		PgPort:      dbPort,
-		DBName:      dbName,
-		AtpDBSchema: atpSchema,
-		CarDBSchema: carSchema,
-		MaxConns:    10,
-		MinConns:    2,
-		MaxConnLife: time.Hour,
-		MaxConnIdle: time.Minute * 30,
-	}
-
-	environment, err := common.GetEnvOrFail("ENVIRONMENT")
-	if err != nil {
-		return nil, err
-	}
-	skey, err := common.GetEnvOrFail("SECRET_KEY")
-	if err != nil {
-		return nil, err
-	}
-	suf, err := common.GetEnvOrFail("HANDLE_SUFFIX")
-	if err != nil {
-		return nil, err
-	}
-	url, err := common.GetEnvOrFail("USER_SERVICE_URL")
-	if err != nil {
-		return nil, err
-	}
-	rkey, err := common.GetEnvOrFail("PDS_RECOVERY_DID_KEY")
-	if err != nil {
-		return nil, err
-	}
-	kd, err := common.GetEnvOrFail("KEYSTORE_DIR")
-	if err != nil {
-		return nil, err
-	}
-	cd, err := common.GetEnvOrFail("CARSTORE_DIR")
-	if err != nil {
-		return nil, err
-	}
-	conn, err := common.GetIntEnv("MAX_CARSTORE_CONNECTIONS")
-	if err != nil {
-		return nil, err
-	}
-	ph, err := common.GetEnvOrFail("PLC_HOST")
-	if err != nil {
-		return nil, err
-	}
-
-	config := &Config{
-		DBConfig: dbConfig,
-		Env:      environment,
-
-		// Server
-		SecretKey: []byte(skey),
-
-		// ATP
-		HandleSuffix: suf,
-		ServiceUrl:   url,
-		RecoveryKey:  rkey,
-		KeyDir:       kd,
-
-		// Carstore
-		CarDir:      cd,
-		CarMaxConns: conn,
-
-		// PLC
-		PLCHost: ph,
-	}
-
-	log.Println("Successfully loaded env vars!")
-
-	return config, nil
-}
diff --git a/user_service/internal/error/validation.go b/user_service/internal/error/validation.go
index 61d6f17..9031126 100644
--- a/user_service/internal/error/validation.go
+++ b/user_service/internal/error/validation.go
@@ -3,10 +3,7 @@ package error
 
 import (
 	"encoding/json"
-	"fmt"
 	"net/http"
-
-	"github.com/go-playground/validator/v10"
 )
 
 type ValidationErrorType string
@@ -40,6 +37,19 @@ func NewValidationFieldError(
 		Type:     errorType,
 		Criteria: criteria,
 	}
+	// detail := ValidationFieldError{
+	// 	FieldError: FieldError{
+	// 		Field:   field,
+	// 		Message: message,
+	// 	},
+	// 	Type:     errorType,
+	// 	Criteria: criteria,
+	// }
+	// return &APIError{
+	// 	Detail:     detail,
+	// 	StatusCode: http.StatusUnprocessableEntity,
+	// 	Code:       ErrorCodeValidation,
+	// }
 }
 
 func ValidationAPIError(validationErrors []*ValidationFieldError) *APIError {
@@ -62,50 +72,3 @@ func WriteFieldErrors(w http.ResponseWriter, fieldErrs []*APIError) {
 		http.Error(w, "Failed to encode API error to JSON", http.StatusInternalServerError)
 	}
 }
-
-// HandleFieldError initializes 'ValidationFieldError' struct with the msg and type based on the validation error
-func HandleFieldError(e validator.FieldError) *ValidationFieldError {
-	var errMsg string
-	var errType ValidationErrorType
-	var criteria []string
-	switch e.ActualTag() {
-	case "required":
-		errMsg = e.StructField() + " is required"
-		errType = MissingField
-	case "name":
-		errMsg = "Invalid name format"
-		errType = InvalidInput
-		criteria = []string{"No special characters allowed", "No numbers allowed", "Check for consecutive spaces"}
-	case "handle":
-		errMsg = "Invalid handle format"
-		errType = InvalidInput
-	case "email":
-		errMsg = "Invalid email format"
-		errType = InvalidInput
-	case "max":
-		errMsg = fmt.Sprintf("%s must not exceed %s characters", e.StructField(), e.Param())
-		errType = InvalidInput
-	case "min":
-		errMsg = fmt.Sprintf("%s must be at least %s characters", e.StructField(), e.Param())
-		errType = InvalidInput
-	case "strongpassword":
-		errMsg = "Password must contain:"
-		errType = InvalidInput
-		criteria = []string{
-			"At least one uppercase letter (A-Z)",
-			"At least one digit (0-9)",
-			"At least one special character",
-		}
-	case "username":
-		errMsg = "Invalid email or handle"
-		errType = InvalidInput
-	case "oneof":
-		errMsg = "Invalid value found"
-		errType = InvalidInput
-	default:
-		errMsg = "Validation failed"
-		errType = InvalidInput
-	}
-
-	return NewValidationFieldError(e.Field(), errMsg, errType, criteria...)
-}
diff --git a/user_service/internal/keymgr/keymgr.go b/user_service/internal/keymgr/keymgr.go
index 787a078..9ae0535 100644
--- a/user_service/internal/keymgr/keymgr.go
+++ b/user_service/internal/keymgr/keymgr.go
@@ -10,6 +10,7 @@ import (
 
 	"github.com/aws/aws-sdk-go-v2/service/kms"
 	"github.com/aws/aws-sdk-go-v2/service/s3"
+	"github.com/referendumApp/referendumServices/internal/env-config"
 	did "github.com/whyrusleeping/go-did"
 )
 
@@ -17,10 +18,9 @@ import (
 type KeyCacher interface {
 	Create(context.Context, string, any) ([]byte, error)
 	Has(context.Context, string) bool
+	Remove(string)
 	Set(context.Context, string, []byte) error
 	Sign(string, []byte) ([]byte, error)
-	Remove(string) error
-	Stop()
 }
 
 // KeyStore method signatures for working with the key store
@@ -41,27 +41,27 @@ type KeyManager struct {
 // NewKeyManager initializes a 'KeyManager' struct
 func NewKeyManager(
 	ctx context.Context,
+	cfg *env.Config,
 	kmsClient *kms.Client,
 	s3Client *s3.Client,
-	env, keyDir, recoveryKey string,
 	eto time.Duration,
 	sto time.Duration,
 	logger *slog.Logger,
 ) (*KeyManager, error) {
 	log.Println("Setting up key manager")
 
-	if env == "local" {
-		if _, err := s3Client.HeadBucket(ctx, &s3.HeadBucketInput{Bucket: &keyDir}); err != nil {
-			log.Printf("The %s bucket does not exist, attempting to create bucket...\n", keyDir)
-			if _, err := s3Client.CreateBucket(ctx, &s3.CreateBucketInput{Bucket: &keyDir}); err != nil {
+	if cfg.Environment == "local" {
+		if _, err := s3Client.HeadBucket(ctx, &s3.HeadBucketInput{Bucket: &cfg.KeyDir}); err != nil {
+			log.Printf("The %s bucket does not exist, attempting to create bucket...\n", cfg.KeyDir)
+			if _, err := s3Client.CreateBucket(ctx, &s3.CreateBucketInput{Bucket: &cfg.KeyDir}); err != nil {
 				return nil, err
 			}
 			log.Println("Successfully created bucket!")
 		}
 	}
 
-	rc := newRepoKeyCache(kmsClient, env, eto, sto)
-	pc, err := newPLCKeyCache(ctx, kmsClient, env, recoveryKey)
+	rc := newRepoKeyCache(kmsClient, cfg.Environment, eto, sto)
+	pc, err := newPLCKeyCache(ctx, kmsClient, cfg.Environment, cfg.RecoveryKey)
 	if err != nil {
 		log.Printf("Failed to generated PLC rotation DID key: %v\n", err)
 		return nil, err
@@ -70,7 +70,7 @@ func NewKeyManager(
 	log.Println("Successfully setup key manager!")
 
 	return &KeyManager{
-		store:         &s3KeyStore{client: s3Client, bucket: keyDir},
+		store:         &s3KeyStore{client: s3Client, bucket: cfg.KeyDir},
 		repoKeyCacher: rc,
 		plcKeyCacher:  pc,
 		log:           logger.With("service", "keymgr"),
@@ -124,10 +124,8 @@ func (km *KeyManager) UpdateKeyCache(ctx context.Context, did string) error {
 }
 
 // InvalidateKeys removes signing and encrypted keys from the cache
-func (km *KeyManager) InvalidateKeys(ctx context.Context, did string) {
-	if err := km.repoKeyCacher.Remove(did); err != nil {
-		km.log.WarnContext(ctx, "Failed to remove signing key from cache", "error", err, "did", did)
-	}
+func (km *KeyManager) InvalidateKeys(did string) {
+	km.repoKeyCacher.Remove(did)
 }
 
 // SignForUser checks for the signing key, refreshes the cache if the key isnt found, and finally signs the commit
@@ -170,19 +168,3 @@ func (km *KeyManager) SignForPLC(ctx context.Context, op []byte) ([]byte, error)
 func (km *KeyManager) VerifyUserSignature(ctx context.Context, did string, sig []byte, msg []byte) error {
 	return fmt.Errorf("VerifyUserSignature not implemented")
 }
-
-func (km *KeyManager) Flush(ctx context.Context) error {
-	done := make(chan struct{})
-
-	go func() {
-		km.repoKeyCacher.Stop()
-		close(done)
-	}()
-
-	select {
-	case <-done:
-		return nil
-	case <-ctx.Done():
-		return ctx.Err()
-	}
-}
diff --git a/user_service/internal/keymgr/repo_cache.go b/user_service/internal/keymgr/repo_cache.go
index cea0e68..286e0c2 100644
--- a/user_service/internal/keymgr/repo_cache.go
+++ b/user_service/internal/keymgr/repo_cache.go
@@ -4,7 +4,6 @@ import (
 	"context"
 	"fmt"
 	"sync"
-	"sync/atomic"
 	"time"
 
 	"github.com/awnumar/memguard"
@@ -27,10 +26,6 @@ func (ec *encryptKeyCache) add(did string, ek []byte) {
 	ec.cache[did] = &encryptKey{value: ek, expiresAt: time.Now().Add(ec.sessionTimeout)}
 }
 
-func (ec *encryptKeyCache) wipe(did string) {
-	delete(ec.cache, did)
-}
-
 type signKeyCache struct {
 	cache          map[string]*signKey
 	sessionTimeout time.Duration
@@ -54,27 +49,12 @@ func (sc *signKeyCache) add(did string, secureBuf *memguard.LockedBuffer) error
 	return nil
 }
 
-func (sc *signKeyCache) wipe(did string) error {
-	sk, exists := sc.cache[did]
-	if !exists {
-		return fmt.Errorf("signing key not found")
-	}
-
-	sk.value = nil
-	sc.cache[did] = nil
-	delete(sc.cache, did)
-
-	return nil
-}
-
 type repoKeyCache struct {
-	kmsClient         *kms.Client
-	encryptKeyCache   *encryptKeyCache
-	signKeyCache      *signKeyCache
-	mu                sync.RWMutex
-	kmsAlias          string
-	shutdownRequested int32
-	stopCh            chan struct{}
+	kmsClient       *kms.Client
+	kmsAlias        string
+	encryptKeyCache *encryptKeyCache
+	signKeyCache    *signKeyCache
+	mu              sync.RWMutex
 }
 
 func newRepoKeyCache(kmsClient *kms.Client, env string, eto time.Duration, sto time.Duration) *repoKeyCache {
@@ -83,7 +63,6 @@ func newRepoKeyCache(kmsClient *kms.Client, env string, eto time.Duration, sto t
 		kmsAlias:        "alias/" + env + "-did-master",
 		encryptKeyCache: &encryptKeyCache{cache: make(map[string]*encryptKey), sessionTimeout: eto},
 		signKeyCache:    &signKeyCache{cache: make(map[string]*signKey), sessionTimeout: sto},
-		stopCh:          make(chan struct{}),
 	}
 
 	go kc.cleanupExpiredKeys()
@@ -162,16 +141,11 @@ func (kc *repoKeyCache) Set(ctx context.Context, did string, key []byte) error {
 }
 
 // Remove removes signing and encrypted keys from the cache
-func (kc *repoKeyCache) Remove(did string) error {
+func (kc *repoKeyCache) Remove(did string) {
 	kc.mu.Lock()
-	defer kc.mu.Unlock()
-
-	kc.encryptKeyCache.wipe(did)
-	if err := kc.signKeyCache.wipe(did); err != nil {
-		return err
-	}
-
-	return nil
+	delete(kc.encryptKeyCache.cache, did)
+	delete(kc.signKeyCache.cache, did)
+	kc.mu.Unlock()
 }
 
 // Sign gets the signing key and returns the signature
@@ -186,63 +160,27 @@ func (kc *repoKeyCache) Sign(did string, cmt []byte) ([]byte, error) {
 	return sk.value.Sign(cmt)
 }
 
-func (kc *repoKeyCache) Stop() {
-	atomic.StoreInt32(&kc.shutdownRequested, 1)
-
-	if kc.stopCh != nil {
-		close(kc.stopCh)
-	}
-
-	kc.mu.Lock()
-	defer kc.mu.Unlock()
-
-	for did := range kc.encryptKeyCache.cache {
-		kc.encryptKeyCache.wipe(did)
-	}
-
-	for did := range kc.signKeyCache.cache {
-		_ = kc.signKeyCache.wipe(did)
-	}
-
-	kc.encryptKeyCache = nil
-	kc.signKeyCache = nil
-}
-
 func (kc *repoKeyCache) cleanupExpiredKeys() {
 	ticker := time.NewTicker(5 * time.Minute)
 	defer ticker.Stop()
 
-	for {
-		select {
-		case <-ticker.C:
-			if atomic.LoadInt32(&kc.shutdownRequested) == 1 {
-				return
-			}
-
-			kc.mu.Lock()
-			now := time.Now()
-
-			for did, ek := range kc.encryptKeyCache.cache {
-				if now.After(ek.expiresAt) {
-					kc.encryptKeyCache.wipe(did)
-					_ = kc.signKeyCache.wipe(did)
-				}
-			}
+	for range ticker.C {
+		kc.mu.Lock()
+		now := time.Now()
 
-			if atomic.LoadInt32(&kc.shutdownRequested) == 1 {
-				kc.mu.Unlock()
-				return
+		for did, ek := range kc.encryptKeyCache.cache {
+			if now.After(ek.expiresAt) {
+				delete(kc.encryptKeyCache.cache, did)
+				delete(kc.signKeyCache.cache, did)
 			}
+		}
 
-			for did, sk := range kc.signKeyCache.cache {
-				if now.After(sk.expiresAt) {
-					_ = kc.signKeyCache.wipe(did)
-				}
+		for did, sk := range kc.signKeyCache.cache {
+			if now.After(sk.expiresAt) {
+				delete(kc.signKeyCache.cache, did)
 			}
-
-			kc.mu.Unlock()
-		case <-kc.stopCh:
-			return
 		}
+
+		kc.mu.Unlock()
 	}
 }
diff --git a/user_service/internal/pds/pds.go b/user_service/internal/pds/pds.go
index 43e415f..3e3e6ee 100644
--- a/user_service/internal/pds/pds.go
+++ b/user_service/internal/pds/pds.go
@@ -2,11 +2,13 @@ package pds
 
 import (
 	"context"
-	"log"
 	"log/slog"
+	"time"
 
 	"github.com/golang-jwt/jwt/v5"
+	"github.com/referendumApp/referendumServices/internal/aws"
 	"github.com/referendumApp/referendumServices/internal/car"
+	"github.com/referendumApp/referendumServices/internal/env-config"
 	"github.com/referendumApp/referendumServices/internal/keymgr"
 	"github.com/referendumApp/referendumServices/internal/plc"
 	"github.com/referendumApp/referendumServices/internal/repo"
@@ -29,34 +31,36 @@ type PDS struct {
 // NewPDS initializes a 'PDS' struct
 func NewPDS(
 	ctx context.Context,
-	km *keymgr.KeyManager,
-	plc plc.ServiceClient,
+	cfg *env.Config,
+	aws *aws.Clients,
 	cs car.Store,
-	handleSuffix, serviceUrl string,
-	secretKey []byte,
 	logger *slog.Logger,
 ) (*PDS, error) {
-	repoman := repo.NewRepoManager(cs, km, logger)
+	pdsLogger := logger.WithGroup("pds")
 
-	// evts := events.NewEventManager(events.NewMemPersister(), logger)
+	atExpiry := 30 * time.Minute
+	rtExpiry := 24 * time.Hour
 
-	// rf := indexer.NewRepoFetcher(db, repoman, 10, logger)
-
-	// idxr, err := indexer.NewIndexer(db, evts, plc, rf, false, true, true)
-	// if err != nil {
-	// 	return nil, err
-	// }
+	km, err := keymgr.NewKeyManager(ctx, cfg, aws.KMS, aws.S3, rtExpiry, atExpiry-(5*time.Minute), pdsLogger)
+	if err != nil {
+		return nil, err
+	}
 
-	// repoman.SetEventHandler(func(ctx context.Context, evt *repo.Event) {
-	// 	if err := idxr.HandleRepoEvent(ctx, evt); err != nil {
-	// 		log.ErrorContext(ctx, "Handle repo event failed", "user", evt.User, "err", err)
-	// 	}
-	// }, true)
+	plc := plc.NewPLCClient(cfg.PLCHost, km, pdsLogger)
 
-	// ix.SendRemoteFollow = srv.sendRemoteFollow
-	// ix.CreateExternalUser = srv.createExternalUser
+	repoman := repo.NewRepoManager(cs, km, pdsLogger)
 
-	jwtConfig := util.NewConfig(secretKey, serviceUrl, jwt.SigningMethodHS256)
+	jwtConfig := &util.JWTConfig{
+		SigningKey:    cfg.SecretKey,
+		SigningMethod: jwt.SigningMethodHS256,
+		Issuer:        cfg.ServiceUrl,
+		SubjectKey:    util.SubjectKey,
+		DidKey:        util.DidKey,
+		TokenLookup:   util.DefaultHeaderAuthorization,
+		AuthScheme:    util.DefaultAuthScheme,
+		TokenExpiry:   atExpiry,
+		RefreshExpiry: rtExpiry,
+	}
 
 	return &PDS{
 		cs:             cs,
@@ -64,25 +68,14 @@ func NewPDS(
 		repoman:        repoman,
 		km:             km,
 		jwt:            jwtConfig,
-		handleSuffix:   handleSuffix,
-		serviceUrl:     serviceUrl,
+		handleSuffix:   cfg.HandleSuffix,
+		serviceUrl:     cfg.ServiceUrl,
 		enforcePeering: false,
-		log:            logger,
+		log:            pdsLogger,
 	}, nil
 }
 
-func (p *PDS) Shutdown(ctx context.Context) error {
-	if p.km != nil {
-		log.Println("Flushing key manager cache")
-		if err := p.km.Flush(ctx); err != nil {
-			log.Printf("error flushing key manager cache: %v\n", err)
-			return err
-		}
-	}
-	return nil
-}
-
-// func (p *PDS) handleFedEvent(ctx context.Context, host *Peering, env *events.XRPCStreamEvent) error {
+// func (s *PDS) handleFedEvent(ctx context.Context, host *Peering, env *events.XRPCStreamEvent) error {
 // 	s.log.InfoContext(ctx, "[%s] got fed event from %q\n", s.serviceUrl, host.Host)
 // 	switch {
 // 	case env.RepoCommit != nil:
@@ -108,7 +101,7 @@ func (p *PDS) Shutdown(ctx context.Context) error {
 // 	}
 // }
 //
-// func (p *PDS) createExternalUser(ctx context.Context, did string) (*atp.Person, error) {
+// func (s *PDS) createExternalUser(ctx context.Context, did string) (*atp.Person, error) {
 // 	doc, err := s.plc.GetDocument(ctx, did)
 // 	if err != nil {
 // 		return nil, fmt.Errorf("could not locate DID document for followed user: %s", err)
@@ -188,7 +181,7 @@ func (p *PDS) Shutdown(ctx context.Context) error {
 // 	return subj, nil
 // }
 
-// func (p *PDS) repoEventToFedEvent(ctx context.Context, evt *repo.RepoEvent) (*atproto.SyncSubscribeRepos_Commit, error) {
+// func (s *PDS) repoEventToFedEvent(ctx context.Context, evt *repo.RepoEvent) (*atproto.SyncSubscribeRepos_Commit, error) {
 // 	did, err := s.db.DidForActor(ctx, evt.User)
 // 	if err != nil {
 // 		return nil, err
@@ -212,7 +205,7 @@ func (p *PDS) Shutdown(ctx context.Context) error {
 // 	return out, nil
 // }
 //
-// func (p *PDS) readRecordFunc(ctx context.Context, user atp.Uid, c cid.Cid) (lexutil.CBOR, error) {
+// func (s *PDS) readRecordFunc(ctx context.Context, user atp.Uid, c cid.Cid) (lexutil.CBOR, error) {
 // 	bs, err := s.cs.ReadOnlySession(user)
 // 	if err != nil {
 // 		return nil, err
@@ -226,7 +219,7 @@ func (p *PDS) Shutdown(ctx context.Context) error {
 // 	return lexutil.CborDecodeValue(blk.RawData())
 // }
 
-// func (p *PDS) HandleResolveDid(c echo.Context) error {
+// func (s *PDS) HandleResolveDid(c echo.Context) error {
 // 	ctx := c.Request().Context()
 //
 // 	handle := c.Request().Host
diff --git a/user_service/internal/pds/server.go b/user_service/internal/pds/server.go
index 7739e40..5fc9e5c 100644
--- a/user_service/internal/pds/server.go
+++ b/user_service/internal/pds/server.go
@@ -3,12 +3,12 @@ package pds
 import (
 	"context"
 	"database/sql"
+	"fmt"
 
 	"github.com/bluesky-social/indigo/api/atproto"
 	"github.com/referendumApp/referendumServices/internal/domain/atp"
 	refApp "github.com/referendumApp/referendumServices/internal/domain/lexicon/referendumapp"
 	refErr "github.com/referendumApp/referendumServices/internal/error"
-	"github.com/referendumApp/referendumServices/internal/plc"
 	"github.com/referendumApp/referendumServices/internal/util"
 )
 
@@ -53,12 +53,51 @@ func (p *PDS) CreateUser(
 	return user, nil
 }
 
+// CreateUser create DID in the PLC directory and initialize a 'User' struct
+func (p *PDS) CreateLegislator(
+	ctx context.Context,
+	req refApp.ServerCreateLegislator_Input,
+	pw string,
+) (*atp.Legislator, *refErr.APIError) {
+
+	// Legislator recovery keys are all the same
+	var recoveryKey string = p.km.RecoveryKey()
+
+	sigkey, err := p.km.CreateSigningKey(ctx)
+	if err != nil {
+		return nil, refErr.InternalServer()
+	}
+
+	var handle = fmt.Sprintf("refLegislator%d", req.LegislatorId)
+
+	did, err := p.plc.CreateDID(ctx, sigkey, []string{recoveryKey, p.km.RotationKey()}, handle, p.serviceUrl)
+	if err != nil {
+		p.log.ErrorContext(ctx, "Failed to create DID", "error", err)
+		return nil, refErr.PLCServer()
+	}
+
+	if err := p.km.CreateEncryptedKey(ctx, did, sigkey); err != nil {
+		p.log.ErrorContext(ctx, "Failed to create encrypted signing key", "error", err)
+		return nil, refErr.InternalServer()
+	}
+
+	user := &atp.User{
+		Handle:         sql.NullString{String: req.Handle, Valid: true},
+		Email:          sql.NullString{String: req.Email, Valid: true},
+		HashedPassword: sql.NullString{String: pw, Valid: true},
+		RecoveryKey:    recoveryKey,
+		Did:            did,
+	}
+
+	return user, nil
+}
+
 // CreateNewRepo initialize a new repo and write the first record to the CAR store
 func (p *PDS) CreateNewRepo(
 	ctx context.Context,
 	user *atp.User,
 	dname string,
-) (*refApp.ServerCreateAccount_Output, *refErr.APIError) {
+) (*refApp.ServerCreateSession_Output, *refErr.APIError) {
 	profile := &refApp.PersonProfile{
 		DisplayName: &dname,
 	}
@@ -73,9 +112,8 @@ func (p *PDS) CreateNewRepo(
 		return nil, refErr.InternalServer()
 	}
 
-	return &refApp.ServerCreateAccount_Output{
+	return &refApp.ServerCreateSession_Output{
 		Did:          user.Did,
-		DisplayName:  dname,
 		Handle:       user.Handle.String,
 		AccessToken:  accessToken,
 		RefreshToken: refreshToken,
@@ -159,8 +197,8 @@ func (p *PDS) RefreshSession(
 	return resp, uid, did, nil
 }
 
-func (p *PDS) DeleteSession(ctx context.Context, did string) *refErr.APIError {
-	p.km.InvalidateKeys(ctx, did)
+func (p *PDS) DeleteSession(did string) *refErr.APIError {
+	p.km.InvalidateKeys(did)
 
 	return nil
 }
@@ -173,14 +211,6 @@ func (p *PDS) DeleteAccount(ctx context.Context, uid atp.Uid, did string) *refEr
 		return refErr.PLCServer()
 	}
 
-	if operation, ok := op.Operation.(*plc.Op); !ok {
-		p.log.ErrorContext(ctx, "Latest operation in PLC audit log is invalid", "did", did)
-		return refErr.BadRequest("Invalid operation in PLC directory audit log")
-	} else if operation.Type == "plc_tombstone" {
-		p.log.ErrorContext(ctx, "User has already been tombstoned in the PLC directory", "did", did)
-		return refErr.BadRequest("User has already been deleted")
-	}
-
 	if err := p.plc.TombstoneDID(ctx, did, op.CID); err != nil {
 		p.log.ErrorContext(ctx, "Tombstone request to PLC directory failed", "error", err)
 		return refErr.PLCServer()
@@ -191,7 +221,7 @@ func (p *PDS) DeleteAccount(ctx context.Context, uid atp.Uid, did string) *refEr
 		return refErr.Repo()
 	}
 
-	p.km.InvalidateKeys(ctx, did)
+	p.km.InvalidateKeys(did)
 
 	return nil
 }
diff --git a/user_service/internal/plc/cbor_gen.go b/user_service/internal/plc/cbor_gen.go
index 8885e18..7fbfc84 100644
--- a/user_service/internal/plc/cbor_gen.go
+++ b/user_service/internal/plc/cbor_gen.go
@@ -18,7 +18,7 @@ var _ = cid.Undef
 var _ = math.E
 var _ = sort.Sort
 
-func (t *Op) MarshalCBOR(w io.Writer) error {
+func (t *CreateOp) MarshalCBOR(w io.Writer) error {
 	if t == nil {
 		_, err := w.Write(cbg.CborNull)
 		return err
@@ -282,8 +282,8 @@ func (t *Op) MarshalCBOR(w io.Writer) error {
 	return nil
 }
 
-func (t *Op) UnmarshalCBOR(r io.Reader) (err error) {
-	*t = Op{}
+func (t *CreateOp) UnmarshalCBOR(r io.Reader) (err error) {
+	*t = CreateOp{}
 
 	cr := cbg.NewCborReader(r)
 
@@ -302,7 +302,7 @@ func (t *Op) UnmarshalCBOR(r io.Reader) (err error) {
 	}
 
 	if extra > cbg.MaxLength {
-		return fmt.Errorf("Op: map struct too large (%d)", extra)
+		return fmt.Errorf("CreateOp: map struct too large (%d)", extra)
 	}
 
 	n := extra
diff --git a/user_service/internal/plc/client.go b/user_service/internal/plc/client.go
index 32bdfe0..a9881e2 100644
--- a/user_service/internal/plc/client.go
+++ b/user_service/internal/plc/client.go
@@ -31,8 +31,8 @@ type ServiceClient interface {
 		service string,
 	) (string, error)
 	UpdateUserHandle(ctx context.Context, didstr string, nhandle string) error
-	GetOpAuditLog(ctx context.Context, did string) ([]LogOp, error)
-	GetLatestOp(ctx context.Context, did string) (*LogOp, error)
+	GetOpAuditLog(ctx context.Context, did string) (*[]Op, error)
+	GetLatestOp(ctx context.Context, did string) (*Op, error)
 	TombstoneDID(ctx context.Context, did string, prev string) error
 }
 
@@ -44,13 +44,13 @@ type Client struct {
 	log  *slog.Logger
 }
 
-// NewClient initializes a 'Client' struct
-func NewClient(host string, km *keymgr.KeyManager, logger *slog.Logger) *Client {
+// NewPLCClient initializes a 'Client' struct
+func NewPLCClient(host string, km *keymgr.KeyManager, logger *slog.Logger) *Client {
 	return &Client{Host: host, C: http.DefaultClient, km: km, log: logger.With("service", "plc")}
 }
 
 // GetDocument returns DID document
-func (c *Client) GetDocument(ctx context.Context, didstr string) (*did.Document, error) {
+func (c Client) GetDocument(ctx context.Context, didstr string) (*did.Document, error) {
 	ctx, span := otel.Tracer("plc").Start(ctx, "plsResolveDid")
 	defer span.End()
 
@@ -77,7 +77,7 @@ func (c *Client) GetDocument(ctx context.Context, didstr string) (*did.Document,
 	if resp.StatusCode != http.StatusOK {
 		b, _ := io.ReadAll(resp.Body)
 		c.log.InfoContext(ctx, "DID doc request to plc directory failed", "body", string(b))
-		return nil, fmt.Errorf("get did request failed: %s", resp.Status)
+		return nil, fmt.Errorf("get did request failed (code %d): %s", resp.StatusCode, resp.Status)
 	}
 
 	var doc did.Document
@@ -89,10 +89,10 @@ func (c *Client) GetDocument(ctx context.Context, didstr string) (*did.Document,
 }
 
 // FlushCacheFor noop
-func (c *Client) FlushCacheFor(did string) {}
+func (c Client) FlushCacheFor(did string) {}
 
 // CreateDID plc_operation for creating and returning a DID
-func (c *Client) CreateDID(
+func (c Client) CreateDID(
 	ctx context.Context,
 	sigkey *did.PrivKey,
 	rotation []string,
@@ -103,7 +103,7 @@ func (c *Client) CreateDID(
 		c.C = http.DefaultClient
 	}
 
-	op := Op{
+	op := CreateOp{
 		Type:                "plc_operation",
 		Services:            map[string]Service{"atproto_pds": {Type: "AtprotoPersonalDataClient", Endpoint: service}},
 		AlsoKnownAs:         []string{handle},
@@ -128,7 +128,10 @@ func (c *Client) CreateDID(
 		return "", err
 	}
 
-	body, _ := json.Marshal(op)
+	body, err := json.Marshal(op) //nolint:errchkjson
+	if err != nil {
+		return "", fmt.Errorf("failed to marshal operation: %w", err)
+	}
 
 	req, err := http.NewRequestWithContext(
 		ctx,
@@ -156,19 +159,31 @@ func (c *Client) CreateDID(
 	if resp.StatusCode != http.StatusOK {
 		b, _ := io.ReadAll(resp.Body)
 		c.log.InfoContext(ctx, "Create PLC operation request failed", "body", string(b))
-		return "", fmt.Errorf("bad response from create call: %s", resp.Status)
+		return "", fmt.Errorf("bad response from create call: %d %s", resp.StatusCode, resp.Status)
 	}
 
 	return opdid, nil
 }
 
 // UpdateUserHandle not implemented
-func (c *Client) UpdateUserHandle(ctx context.Context, did string, handle string) error {
+func (c Client) UpdateUserHandle(ctx context.Context, did string, handle string) error {
 	return fmt.Errorf("handle updates not yet implemented")
 }
 
+func didForCreateOp(op *CreateOp) (string, error) {
+	buf := new(bytes.Buffer)
+	if err := op.MarshalCBOR(buf); err != nil {
+		return "", err
+	}
+
+	h := sha256.Sum256(buf.Bytes())
+	enchash := base32.StdEncoding.EncodeToString(h[:])
+	enchash = strings.ToLower(enchash)
+	return "did:plc:" + enchash[:24], nil
+}
+
 // GetOpAuditLog returns all PLC directory operations
-func (c *Client) GetOpAuditLog(ctx context.Context, did string) ([]LogOp, error) {
+func (c Client) GetOpAuditLog(ctx context.Context, did string) (*[]Op, error) {
 	if c.C == nil {
 		c.C = http.DefaultClient
 	}
@@ -192,19 +207,19 @@ func (c *Client) GetOpAuditLog(ctx context.Context, did string) ([]LogOp, error)
 	if resp.StatusCode != http.StatusOK {
 		b, _ := io.ReadAll(resp.Body)
 		c.log.InfoContext(ctx, "Audit log request to plc directory failed", "body", string(b))
-		return nil, fmt.Errorf("get last op request failed: %s", resp.Status)
+		return nil, fmt.Errorf("get last op request failed (code %d): %s", resp.StatusCode, resp.Status)
 	}
 
-	var log []LogOp
+	var log []Op
 	if err := json.NewDecoder(resp.Body).Decode(&log); err != nil {
 		return nil, err
 	}
 
-	return log, nil
+	return &log, nil
 }
 
 // TombstoneDID plc_operation for deleting/deactivating a DID
-func (c *Client) TombstoneDID(ctx context.Context, did string, prev string) error {
+func (c Client) TombstoneDID(ctx context.Context, did string, prev string) error {
 	if c.C == nil {
 		c.C = http.DefaultClient
 	}
@@ -223,7 +238,11 @@ func (c *Client) TombstoneDID(ctx context.Context, did string, prev string) erro
 
 	op.Sig = base64.RawURLEncoding.EncodeToString(sig)
 
-	body, _ := json.Marshal(op)
+	body, err := json.Marshal(op) //nolint:errchkjson
+	if err != nil {
+		c.log.InfoContext(ctx, "Failed to marshal tombstone operation", "error", err)
+		return err
+	}
 
 	req, err := http.NewRequestWithContext(ctx, http.MethodPost, c.Host+"/"+url.QueryEscape(did), bytes.NewReader(body))
 	if err != nil {
@@ -246,20 +265,19 @@ func (c *Client) TombstoneDID(ctx context.Context, did string, prev string) erro
 	if resp.StatusCode != http.StatusOK {
 		b, _ := io.ReadAll(resp.Body)
 		c.log.InfoContext(ctx, "Tombstone request to plc directory failed", "body", string(b))
-		return fmt.Errorf("bad response from tombstone call: %s", resp.Status)
+		return fmt.Errorf("bad response from tombstone call: %d %s", resp.StatusCode, resp.Status)
 	}
 
 	return nil
 }
 
 // GetLatestOp wrapper around 'GetOpAuditLog' that returns the latest 'Op'
-func (c *Client) GetLatestOp(ctx context.Context, did string) (*LogOp, error) {
+func (c Client) GetLatestOp(ctx context.Context, did string) (*Op, error) {
 	log, err := c.GetOpAuditLog(ctx, did)
 	if err != nil {
 		return nil, err
 	}
 
-	c.log.InfoContext(ctx, "Audit log", "log", log)
 	op, err := findLatestOp(log)
 	if err != nil {
 		c.log.InfoContext(ctx, "Failed to get the latest PLC operation", "err", err)
@@ -268,31 +286,3 @@ func (c *Client) GetLatestOp(ctx context.Context, did string) (*LogOp, error) {
 
 	return op, nil
 }
-
-func findLatestOp(log []LogOp) (*LogOp, error) {
-	if len(log) == 0 {
-		return nil, fmt.Errorf("no operations found in PLC log")
-	}
-
-	newest := &log[0]
-
-	for _, op := range log[1:] {
-		if op.CreatedAt.After(newest.CreatedAt) {
-			newest = &op
-		}
-	}
-
-	return newest, nil
-}
-
-func didForCreateOp(op *Op) (string, error) {
-	buf := new(bytes.Buffer)
-	if err := op.MarshalCBOR(buf); err != nil {
-		return "", err
-	}
-
-	h := sha256.Sum256(buf.Bytes())
-	enchash := base32.StdEncoding.EncodeToString(h[:])
-	enchash = strings.ToLower(enchash)
-	return "did:plc:" + enchash[:24], nil
-}
diff --git a/user_service/internal/plc/models.go b/user_service/internal/plc/models.go
index 7ffacef..4a38d54 100644
--- a/user_service/internal/plc/models.go
+++ b/user_service/internal/plc/models.go
@@ -1,10 +1,9 @@
 package plc
 
 import (
-	"encoding/json"
+	"fmt"
 	"time"
 
-	cbg "github.com/whyrusleeping/cbor-gen"
 	did "github.com/whyrusleeping/go-did"
 )
 
@@ -14,8 +13,8 @@ type Service struct {
 	Endpoint string `json:"endpoint" cborgen:"endpoint"`
 }
 
-// Op PLC operation schema
-type Op struct {
+// CreateOp PLC operation schema for creating a DID
+type CreateOp struct {
 	Prev                *string            `json:"prev"                cborgen:"prev"`
 	Type                string             `json:"type"                cborgen:"type"`
 	Sig                 string             `json:"sig"                 cborgen:"sig,omitempty"`
@@ -32,39 +31,29 @@ type TombstoneOp struct {
 	Sig  string `json:"sig"  cborgen:"sig,omitempty"`
 }
 
-type Operation interface {
-	cbg.CBORMarshaler
-	cbg.CBORUnmarshaler
-}
-
-// LogOp response schema from PLC server
-type LogOp struct {
+// Op response schema from PLC server
+type Op struct {
 	DID       did.DID   `json:"did"`
-	Operation Operation `json:"operation"`
+	Operation CreateOp  `json:"operation"`
 	CID       string    `json:"cid"`
 	Nullified bool      `json:"nullfied"`
 	CreatedAt time.Time `json:"createdAt"`
 }
 
-func (l *LogOp) UnmarshalJSON(data []byte) error {
-	type TempLogOp struct {
-		DID       did.DID   `json:"did"`
-		Operation *Op       `json:"operation"`
-		CID       string    `json:"cid"`
-		Nullified bool      `json:"nullified"`
-		CreatedAt time.Time `json:"createdAt"`
-	}
+func findLatestOp(log *[]Op) (*Op, error) {
+	derefLog := *log
 
-	var temp TempLogOp
-	if err := json.Unmarshal(data, &temp); err != nil {
-		return err
+	if len(derefLog) == 0 {
+		return nil, fmt.Errorf("no operations found in PLC log")
 	}
 
-	l.DID = temp.DID
-	l.Operation = temp.Operation
-	l.CID = temp.CID
-	l.Nullified = temp.Nullified
-	l.CreatedAt = temp.CreatedAt
+	newest := &derefLog[0]
+
+	for _, op := range derefLog[1:] {
+		if op.CreatedAt.After(newest.CreatedAt) {
+			newest = &op
+		}
+	}
 
-	return nil
+	return newest, nil
 }
diff --git a/user_service/internal/plc/test_client.go b/user_service/internal/plc/test_client.go
deleted file mode 100644
index 519cb0c..0000000
--- a/user_service/internal/plc/test_client.go
+++ /dev/null
@@ -1,188 +0,0 @@
-package plc
-
-import (
-	"bytes"
-	"context"
-	"encoding/base64"
-	"fmt"
-	"sync"
-	"time"
-
-	cid "github.com/ipfs/go-cid"
-	mh "github.com/multiformats/go-multihash"
-	"github.com/referendumApp/referendumServices/internal/keymgr"
-	cbg "github.com/whyrusleeping/cbor-gen"
-	godid "github.com/whyrusleeping/go-did"
-)
-
-// TestClient contains test dependencies
-type TestClient struct {
-	km     *keymgr.KeyManager
-	didDoc map[string]*godid.Document
-	opLog  map[string][]LogOp
-	lk     sync.RWMutex
-}
-
-// NewTestClient initializes a 'TestClient' struct
-func NewTestClient(km *keymgr.KeyManager) *TestClient {
-	return &TestClient{km: km, didDoc: make(map[string]*godid.Document), opLog: make(map[string][]LogOp)}
-}
-
-// GetDocument returns DID document
-func (c *TestClient) GetDocument(ctx context.Context, didstr string) (*godid.Document, error) {
-	c.lk.RLock()
-	defer c.lk.RUnlock()
-
-	return c.didDoc[didstr], nil
-}
-
-// FlushCacheFor noop
-func (c *TestClient) FlushCacheFor(did string) {}
-
-// CreateDID plc_operation for creating and returning a DID
-func (c *TestClient) CreateDID(
-	ctx context.Context,
-	sigkey *godid.PrivKey,
-	rotation []string,
-	handle string,
-	service string,
-) (string, error) {
-	op := &Op{
-		Type:                "plc_operation",
-		Services:            map[string]Service{"atproto_pds": {Type: "AtprotoPersonalDataClient", Endpoint: service}},
-		AlsoKnownAs:         []string{handle},
-		RotationKeys:        rotation,
-		VerificationMethods: map[string]string{"atproto": sigkey.Public().DID()},
-	}
-
-	buf := new(bytes.Buffer)
-	if err := op.MarshalCBOR(buf); err != nil {
-		return "", err
-	}
-
-	sig, err := c.km.SignForPLC(ctx, buf.Bytes())
-	if err != nil {
-		return "", err
-	}
-
-	op.Sig = base64.RawURLEncoding.EncodeToString(sig)
-
-	opdid, err := didForCreateOp(op)
-	if err != nil {
-		return "", err
-	}
-
-	c.lk.Lock()
-	defer c.lk.Unlock()
-
-	opCid, err := generateCid(op)
-	if err != nil {
-		return "", err
-	}
-
-	didObj, err := godid.ParseDID(opdid)
-	if err != nil {
-		return "", err
-	}
-	c.opLog[opdid] = []LogOp{
-		{
-			DID:       didObj,
-			Operation: op,
-			CID:       opCid.String(),
-			Nullified: false,
-			CreatedAt: time.Now(),
-		},
-	}
-
-	return opdid, nil
-}
-
-// UpdateUserHandle noop
-func (c *TestClient) UpdateUserHandle(ctx context.Context, did string, handle string) error {
-	return fmt.Errorf("handle updates not yet implemented")
-}
-
-// GetOpAuditLog returns all PLC directory operations
-func (c *TestClient) GetOpAuditLog(ctx context.Context, did string) ([]LogOp, error) {
-	c.lk.RLock()
-	defer c.lk.RUnlock()
-	log := c.opLog[did]
-
-	return log, nil
-}
-
-// TombstoneDID plc_operation for deleting/deactivating a DID
-func (c *TestClient) TombstoneDID(ctx context.Context, did string, prev string) error {
-	op := &TombstoneOp{Type: "plc_tombstone", Prev: prev}
-
-	buf := new(bytes.Buffer)
-	if err := op.MarshalCBOR(buf); err != nil {
-		return err
-	}
-
-	sig, err := c.km.SignForPLC(ctx, buf.Bytes())
-	if err != nil {
-		return err
-	}
-
-	op.Sig = base64.RawURLEncoding.EncodeToString(sig)
-	opCid, err := generateCid(op)
-	if err != nil {
-		return err
-	}
-
-	didObj, err := godid.ParseDID(did)
-	if err != nil {
-		return err
-	}
-
-	tombOp := LogOp{
-		DID:       didObj,
-		Operation: op,
-		CID:       opCid.String(),
-		Nullified: false,
-		CreatedAt: time.Now(),
-	}
-
-	c.lk.Lock()
-	defer c.lk.Unlock()
-	opLog := c.opLog[did]
-	c.opLog[did] = append(opLog, tombOp)
-	delete(c.didDoc, did)
-
-	return nil
-}
-
-// GetLatestOp wrapper around 'GetOpAuditLog' that returns the latest 'Op'
-func (c *TestClient) GetLatestOp(ctx context.Context, did string) (*LogOp, error) {
-	log, err := c.GetOpAuditLog(ctx, did)
-	if err != nil {
-		return nil, err
-	}
-
-	op, err := findLatestOp(log)
-	if err != nil {
-		return nil, err
-	}
-
-	return op, nil
-}
-
-func generateCid(op cbg.CBORMarshaler) (cid.Cid, error) {
-	cidBuf := new(bytes.Buffer)
-	if err := op.MarshalCBOR(cidBuf); err != nil {
-		return cid.Undef, err
-	}
-	pref := cid.Prefix{
-		Codec:    uint64(cid.DagCBOR),
-		MhType:   mh.SHA2_256,
-		MhLength: -1,
-		Version:  1,
-	}
-	c, err := pref.Sum(cidBuf.Bytes())
-	if err != nil {
-		return cid.Undef, err
-	}
-
-	return c, nil
-}
diff --git a/user_service/internal/service/handlers.go b/user_service/internal/server/handlers.go
similarity index 73%
rename from user_service/internal/service/handlers.go
rename to user_service/internal/server/handlers.go
index d5c6caa..6988f90 100644
--- a/user_service/internal/service/handlers.go
+++ b/user_service/internal/server/handlers.go
@@ -1,4 +1,4 @@
-package service
+package server
 
 import (
 	"net/http"
@@ -9,7 +9,7 @@ import (
 	"github.com/referendumApp/referendumServices/internal/util"
 )
 
-func (s *Service) handleHealth(w http.ResponseWriter, r *http.Request) {
+func (s *Server) handleHealth(w http.ResponseWriter, r *http.Request) {
 	if err := s.av.HandleHealth(w, r); err != nil {
 		err.WriteResponse(w)
 		return
@@ -25,12 +25,12 @@ func (s *Service) handleHealth(w http.ResponseWriter, r *http.Request) {
 	s.encode(r.Context(), w, http.StatusOK, resp)
 }
 
-func (s *Service) handleDescribeServer(w http.ResponseWriter, r *http.Request) {
+func (s *Server) handleDescribeServer(w http.ResponseWriter, r *http.Request) {
 	resp := s.pds.HandleAtprotoDescribeServer()
 	s.encode(r.Context(), w, http.StatusOK, resp)
 }
 
-func (s *Service) handleCreateAccount(w http.ResponseWriter, r *http.Request) {
+func (s *Server) handleCreateAccount(w http.ResponseWriter, r *http.Request) {
 	ctx := r.Context()
 
 	var req refApp.ServerCreateAccount_Input
@@ -64,7 +64,44 @@ func (s *Service) handleCreateAccount(w http.ResponseWriter, r *http.Request) {
 	s.encode(ctx, w, http.StatusCreated, resp)
 }
 
-func (s *Service) handleCreateSession(w http.ResponseWriter, r *http.Request) {
+func (s *Server) handleCreateLegislator(w http.ResponseWriter, r *http.Request) {
+	ctx := r.Context()
+
+	var req refApp.ServerCreateLegislator_Input
+	if err := s.decodeAndValidate(ctx, w, r.Body, &req); err != nil {
+		return
+	}
+
+	// pw, err := s.av.ResolveHandle(ctx, &req)
+	//
+	//	if err != nil {
+	//		err.WriteResponse(w)
+	//		return
+	//	}
+	//
+	// user, err := s.pds.CreateUser(ctx, req, pw)
+	//
+	//	if err != nil {
+	//		err.WriteResponse(w)
+	//		return
+	//	}
+	//
+	//	if cerr := s.av.CreateUserAndPerson(ctx, user, req.Handle, req.DisplayName); cerr != nil {
+	//		cerr.WriteResponse(w)
+	//		return
+	//	}
+	//
+	// resp, err := s.pds.CreateNewRepo(ctx, user, req.DisplayName)
+	//
+	//	if err != nil {
+	//		err.WriteResponse(w)
+	//		return
+	//	}
+	//
+	// s.encode(ctx, w, http.StatusCreated, resp)
+}
+
+func (s *Server) handleCreateSession(w http.ResponseWriter, r *http.Request) {
 	ctx := r.Context()
 
 	if err := r.ParseForm(); err != nil {
@@ -97,10 +134,10 @@ func (s *Service) handleCreateSession(w http.ResponseWriter, r *http.Request) {
 		return
 	}
 
-	s.encode(ctx, w, http.StatusCreated, resp)
+	s.encode(ctx, w, http.StatusOK, resp)
 }
 
-func (s *Service) handleRefreshSession(w http.ResponseWriter, r *http.Request) {
+func (s *Server) handleRefreshSession(w http.ResponseWriter, r *http.Request) {
 	ctx := r.Context()
 
 	var req refApp.ServerRefreshSession_Input
@@ -122,22 +159,20 @@ func (s *Service) handleRefreshSession(w http.ResponseWriter, r *http.Request) {
 	s.encode(ctx, w, http.StatusOK, resp)
 }
 
-func (s *Service) handleDeleteSession(w http.ResponseWriter, r *http.Request) {
-	ctx := r.Context()
-
-	_, did, err := s.getAndValidatePerson(ctx)
+func (s *Server) handleDeleteSession(w http.ResponseWriter, r *http.Request) {
+	_, did, err := s.getAndValidatePerson(r.Context())
 	if err != nil {
 		err.WriteResponse(w)
 		return
 	}
 
-	if err := s.pds.DeleteSession(ctx, did); err != nil {
+	if err := s.pds.DeleteSession(did); err != nil {
 		err.WriteResponse(w)
 		return
 	}
 }
 
-func (s *Service) handleDeleteAccount(w http.ResponseWriter, r *http.Request) {
+func (s *Server) handleDeleteAccount(w http.ResponseWriter, r *http.Request) {
 	ctx := r.Context()
 
 	uid, did, err := s.getAndValidatePerson(ctx)
@@ -157,7 +192,7 @@ func (s *Service) handleDeleteAccount(w http.ResponseWriter, r *http.Request) {
 	}
 }
 
-func (s *Service) handleProfileUpdate(w http.ResponseWriter, r *http.Request) {
+func (s *Server) handleProfileUpdate(w http.ResponseWriter, r *http.Request) {
 	ctx := r.Context()
 
 	var req refApp.PersonUpdateProfile_Input
@@ -188,7 +223,7 @@ func (s *Service) handleProfileUpdate(w http.ResponseWriter, r *http.Request) {
 	}
 }
 
-func (s *Service) handleGetProfile(w http.ResponseWriter, r *http.Request) {
+func (s *Server) handleGetProfile(w http.ResponseWriter, r *http.Request) {
 	ctx := r.Context()
 
 	uid, _, err := s.getAndValidatePerson(ctx)
@@ -211,7 +246,7 @@ func (s *Service) handleGetProfile(w http.ResponseWriter, r *http.Request) {
 	s.encode(ctx, w, http.StatusOK, profile)
 }
 
-func (s *Service) handleGraphFollow(w http.ResponseWriter, r *http.Request) {
+func (s *Server) handleGraphFollow(w http.ResponseWriter, r *http.Request) {
 	ctx := r.Context()
 
 	var req refApp.GraphFollow_Input
@@ -238,7 +273,7 @@ func (s *Service) handleGraphFollow(w http.ResponseWriter, r *http.Request) {
 	}
 }
 
-func (s *Service) handleGraphFollowers(w http.ResponseWriter, r *http.Request) {
+func (s *Server) handleGraphFollowers(w http.ResponseWriter, r *http.Request) {
 	ctx := r.Context()
 
 	uid, _, err := s.getAndValidatePerson(ctx)
@@ -256,7 +291,7 @@ func (s *Service) handleGraphFollowers(w http.ResponseWriter, r *http.Request) {
 	s.encode(ctx, w, http.StatusOK, followers)
 }
 
-func (s *Service) handleGraphFollowing(w http.ResponseWriter, r *http.Request) {
+func (s *Server) handleGraphFollowing(w http.ResponseWriter, r *http.Request) {
 	ctx := r.Context()
 
 	uid, _, err := s.getAndValidatePerson(ctx)
diff --git a/user_service/internal/service/middleware.go b/user_service/internal/server/middleware.go
similarity index 65%
rename from user_service/internal/service/middleware.go
rename to user_service/internal/server/middleware.go
index 92fb48b..5cb4419 100644
--- a/user_service/internal/service/middleware.go
+++ b/user_service/internal/server/middleware.go
@@ -1,8 +1,7 @@
-package service
+package server
 
 import (
 	"bufio"
-	"context"
 	"fmt"
 	"net"
 	"net/http"
@@ -39,7 +38,7 @@ func getOrCreateCustomWriter(w http.ResponseWriter) *CustomResponseWriter {
 	}
 }
 
-func (s *Service) logRequest(next http.Handler) http.Handler {
+func (s *Server) logRequest(next http.Handler) http.Handler {
 	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
 		startTime := time.Now()
 
@@ -58,8 +57,10 @@ func (s *Service) logRequest(next http.Handler) http.Handler {
 			r.RemoteAddr,
 		)
 
+		// Call the next handler
 		next.ServeHTTP(rw, r)
 
+		// Log completion time
 		duration := fmt.Sprintf("%d ms", time.Since(startTime).Milliseconds())
 		s.log.InfoContext(
 			r.Context(),
@@ -75,30 +76,3 @@ func (s *Service) logRequest(next http.Handler) http.Handler {
 		)
 	})
 }
-
-func withCancellation(parent context.Context, ch <-chan struct{}) (context.Context, context.CancelFunc) {
-	ctx, cancel := context.WithCancel(parent)
-	go func() {
-		select {
-		case <-ch:
-			cancel()
-		case <-ctx.Done():
-		}
-	}()
-	return ctx, cancel
-}
-
-func (s *Service) gracefulShutdown(next http.Handler, cancelCh <-chan struct{}) http.Handler {
-	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
-		ctx, cancel := withCancellation(r.Context(), cancelCh)
-		defer cancel()
-		r = r.WithContext(ctx)
-		next.ServeHTTP(w, r)
-	})
-}
-
-func (s *Service) requestTimeout(next http.Handler) http.Handler {
-	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
-		http.TimeoutHandler(next, 15*time.Second, "Request timed out").ServeHTTP(w, r)
-	})
-}
diff --git a/user_service/internal/service/routes.go b/user_service/internal/server/routes.go
similarity index 66%
rename from user_service/internal/service/routes.go
rename to user_service/internal/server/routes.go
index cd235b3..f9352f4 100644
--- a/user_service/internal/service/routes.go
+++ b/user_service/internal/server/routes.go
@@ -1,15 +1,16 @@
-package service
+package server
 
 import "github.com/go-chi/chi/v5"
 
-func (s *Service) setupRoutes() {
+// Server method for handling routers
+func (s *Server) setupRoutes() {
 	s.mux.Get("/health", s.handleHealth)
 
 	s.mux.Route("/auth", func(r chi.Router) {
 		r.Post("/signup", s.handleCreateAccount)
 		r.Post("/login", s.handleCreateSession)
 		r.Post("/refresh", s.handleRefreshSession)
-		r.With(s.pds.AuthorizeUser).Delete("/", s.handleDeleteSession)
+		r.Delete("/", s.handleDeleteSession)
 	})
 
 	s.mux.Route("/user", func(r chi.Router) {
@@ -24,6 +25,15 @@ func (s *Service) setupRoutes() {
 		r.Get("/following", s.handleGraphFollowing)
 	})
 
+	s.mux.Route("/legislator", func(r chi.Router) {
+		// 		r.Use(s.pds.AuthorizeUser)
+
+		r.Post("/", s.handleCreateLegislator)
+		// 		r.Get("/", s.handleGetLegislator)
+		// 		r.Put("/", s.handleLegislatorUpdate)
+		// 		r.Delete("/", s.handleDeleteLegislator)
+	})
+
 	s.mux.Route("/server", func(r chi.Router) {
 		r.Get("/describeServer", s.handleDescribeServer)
 		// r.Get("/com.atproto.sync.subscribeRepos", s.pds.EventsHandler)
diff --git a/user_service/internal/server/server.go b/user_service/internal/server/server.go
new file mode 100644
index 0000000..dd93f49
--- /dev/null
+++ b/user_service/internal/server/server.go
@@ -0,0 +1,129 @@
+package server
+
+import (
+	"context"
+	"fmt"
+	"log"
+	"log/slog"
+	"net/http"
+	"time"
+
+	"github.com/go-chi/chi/v5"
+	"github.com/referendumApp/referendumServices/internal/app"
+	"github.com/referendumApp/referendumServices/internal/aws"
+	"github.com/referendumApp/referendumServices/internal/car"
+	"github.com/referendumApp/referendumServices/internal/database"
+	"github.com/referendumApp/referendumServices/internal/env-config"
+	"github.com/referendumApp/referendumServices/internal/pds"
+)
+
+// Server abstraction layer around PDS and App View modules
+type Server struct {
+	httpServer *http.Server
+	db         *database.DB
+	mux        *chi.Mux
+	av         *app.View
+	pds        *pds.PDS
+	port       int16
+	log        *slog.Logger
+}
+
+// New initialize 'Server' struct, setup HTTP routes, and middleware
+func New(ctx context.Context, cfg *env.Config, db *database.DB, logger *slog.Logger) (*Server, error) {
+	clients, err := aws.NewClients(ctx, cfg.Environment)
+	if err != nil {
+		return nil, err
+	}
+
+	cs, err := car.NewCarStore(ctx, cfg, db, clients.S3, logger)
+	if err != nil {
+		return nil, err
+	}
+
+	// evts := events.NewEventManager(events.NewMemPersister(), logger)
+
+	// kmgr := indexer.NewKeyManager(plc, srvkey, logger)
+
+	// repoman := repo.NewRepoManager(cs, kmgr, logger)
+
+	// rf := indexer.NewRepoFetcher(db, repoman, 10, logger)
+
+	// idxr, err := indexer.NewIndexer(db, evts, plc, rf, false, true, true)
+	// if err != nil {
+	// 	return nil, err
+	// }
+
+	// repoman.SetEventHandler(func(ctx context.Context, evt *repo.Event) {
+	// 	if err := idxr.HandleRepoEvent(ctx, evt); err != nil {
+	// 		log.ErrorContext(ctx, "Handle repo event failed", "user", evt.User, "err", err)
+	// 	}
+	// }, true)
+
+	av := app.NewAppView(db, cfg, logger)
+
+	pds, err := pds.NewPDS(ctx, cfg, clients, cs, logger)
+	if err != nil {
+		return nil, err
+	}
+
+	srv := &Server{
+		mux:  chi.NewRouter(),
+		av:   av,
+		pds:  pds,
+		port: 80,
+		log:  logger,
+	}
+
+	// ix.SendRemoteFollow = srv.sendRemoteFollow
+	// ix.CreateExternalUser = srv.createExternalUser
+
+	srv.mux.Use(srv.logRequest)
+	srv.setupRoutes()
+
+	srv.httpServer = &http.Server{
+		Addr:         fmt.Sprintf(":%d", srv.port),
+		Handler:      srv.mux,
+		ReadTimeout:  5 * time.Second,
+		WriteTimeout: 10 * time.Second,
+		IdleTimeout:  15 * time.Second,
+	}
+
+	return srv, nil
+}
+
+// Start configure HTTP Server, listen and server requests, handle shutdowns gracefully
+func (s *Server) Start(ctx context.Context) error {
+	errChan := make(chan error, 1)
+
+	// ListenAndServe is blocking so call it in a go routine to run it concurrently
+	go func() {
+		log.Printf("Server starting on port %d\n", s.port)
+		if err := s.httpServer.ListenAndServe(); err != nil && err != http.ErrServerClosed {
+			log.Println("Error listening and serving")
+			errChan <- err
+		}
+	}()
+
+	select {
+	case <-ctx.Done():
+		log.Println("Shutdown signal received")
+	case err := <-errChan:
+		return fmt.Errorf("server error: %w", err)
+	}
+
+	return nil
+}
+
+// Shutdown http server and DB
+func (s *Server) Shutdown(ctx context.Context) error {
+	log.Println("Shutdown server...")
+	if err := s.httpServer.Shutdown(ctx); err != nil {
+		return fmt.Errorf("shutdown error: %w", err)
+	}
+
+	if s.db != nil {
+		s.db.Close()
+	}
+
+	return nil
+}
diff --git a/user_service/internal/service/util.go b/user_service/internal/server/util.go
similarity index 77%
rename from user_service/internal/service/util.go
rename to user_service/internal/server/util.go
index 91afd6e..cac4591 100644
--- a/user_service/internal/service/util.go
+++ b/user_service/internal/server/util.go
@@ -1,4 +1,4 @@
-package service
+package server
 
 import (
 	"context"
@@ -15,10 +15,10 @@ import (
 
 var ErrUnauthorized = errors.New("unauthorized user request")
 
-func (s *Service) getAndValidatePerson(ctx context.Context) (atp.Uid, string, *refErr.APIError) {
+func (s *Server) getAndValidatePerson(ctx context.Context) (atp.Uid, string, *refErr.APIError) {
 	uid, ok := ctx.Value(util.SubjectKey).(atp.Uid)
 	if !ok {
-		s.log.ErrorContext(ctx, "Invalid user ID", "uid", uid)
+		s.log.ErrorContext(ctx, "Invalid user ID")
 		return 0, "", refErr.Unauthorized(ErrUnauthorized.Error())
 	}
 	did, ok := ctx.Value(util.DidKey).(string)
@@ -29,7 +29,7 @@ func (s *Service) getAndValidatePerson(ctx context.Context) (atp.Uid, string, *r
 	return uid, did, nil
 }
 
-func (s *Service) handleValidationErrors(ctx context.Context, err error) *refErr.APIError {
+func (s *Server) handleValidationErrors(ctx context.Context, err error) *refErr.APIError {
 	var valErr validator.ValidationErrors
 	if errors.As(err, &valErr) {
 		fieldErrs := make([]*refErr.ValidationFieldError, 0, len(valErr))
@@ -44,7 +44,7 @@ func (s *Service) handleValidationErrors(ctx context.Context, err error) *refErr
 				"error",
 				e.Error(),
 			)
-			fieldErr := refErr.HandleFieldError(e)
+			fieldErr := util.HandleFieldError(e)
 			fieldErrs = append(fieldErrs, fieldErr)
 		}
 		return refErr.ValidationAPIError(fieldErrs)
@@ -52,7 +52,7 @@ func (s *Service) handleValidationErrors(ctx context.Context, err error) *refErr
 	return nil
 }
 
-func (s *Service) encode(ctx context.Context, w http.ResponseWriter, status int, v any) {
+func (s *Server) encode(ctx context.Context, w http.ResponseWriter, status int, v any) {
 	w.Header().Set("Content-Type", "application/json")
 	w.WriteHeader(status)
 	if err := json.NewEncoder(w).Encode(v); err != nil {
@@ -62,7 +62,7 @@ func (s *Service) encode(ctx context.Context, w http.ResponseWriter, status int,
 	}
 }
 
-func (s *Service) decodeAndValidate(ctx context.Context, w http.ResponseWriter, body io.ReadCloser, v any) error {
+func (s *Server) decodeAndValidate(ctx context.Context, w http.ResponseWriter, body io.ReadCloser, v any) error {
 	if err := json.NewDecoder(body).Decode(v); err != nil {
 		s.log.ErrorContext(ctx, "Failed to decode request body", "error", err)
 		refErr.UnproccessableEntity("Invalid entity").WriteResponse(w)
diff --git a/user_service/internal/service/integration_test.go b/user_service/internal/service/integration_test.go
deleted file mode 100644
index 727baf9..0000000
--- a/user_service/internal/service/integration_test.go
+++ /dev/null
@@ -1,854 +0,0 @@
-//go:build integration
-
-package service
-
-import (
-	"bytes"
-	"context"
-	"encoding/json"
-	"errors"
-	"log"
-	"log/slog"
-	"net/http"
-	"net/url"
-	"os"
-	"strings"
-	"testing"
-	"time"
-
-	"github.com/golang-jwt/jwt/v5"
-	"github.com/referendumApp/referendumServices/internal/app"
-	"github.com/referendumApp/referendumServices/internal/aws"
-	"github.com/referendumApp/referendumServices/internal/car"
-	"github.com/referendumApp/referendumServices/internal/database"
-	refApp "github.com/referendumApp/referendumServices/internal/domain/lexicon/referendumapp"
-	"github.com/referendumApp/referendumServices/internal/env-config"
-	"github.com/referendumApp/referendumServices/internal/keymgr"
-	"github.com/referendumApp/referendumServices/internal/pds"
-	"github.com/referendumApp/referendumServices/internal/plc"
-	"github.com/referendumApp/referendumServices/internal/util"
-	"github.com/referendumApp/referendumServices/testutil"
-	"github.com/stretchr/testify/assert"
-)
-
-const (
-	baseUrl = "http://localhost:80"
-	handle  = "k1ng.referendumapp.com"
-	email   = "ken@referendumapp.com"
-	pw      = "Testing123$"
-)
-
-var (
-	testService  *Service
-	client       *http.Client
-	accessToken  string
-	refreshToken string
-)
-
-func setupAndRunTests(m *testing.M, servChErr chan error) int {
-	defer close(servChErr)
-
-	ctx, cancel := context.WithCancel(context.Background())
-	defer cancel()
-
-	logger := slog.Default()
-	cfg, err := env.LoadConfig()
-	if err != nil {
-		log.Printf("Failed to load environment variables: %v\n", err)
-		os.Exit(1)
-	}
-
-	docker, err := testutil.SetupDocker()
-	if err != nil {
-		log.Printf("Failed to setup docker API and network: %v\n", err)
-		return 1
-	}
-	defer docker.CleanupDocker()
-
-	pc, err := docker.SetupPostgres(ctx, cfg.DBConfig)
-	if err != nil {
-		log.Printf("Failed to setup postgres container: %v\n", err)
-		return 1
-	}
-	defer pc.CleanupPostgres(docker)
-
-	sc, err := docker.SetupS3(ctx)
-	if err != nil {
-		log.Printf("Failed to setup minio container: %v\n", err)
-		return 1
-	}
-	defer sc.CleanupS3(docker)
-
-	kms, err := docker.SetupKMS(ctx, cfg)
-	if err != nil {
-		log.Printf("Failed to setup kms container: %v\n", err)
-		return 1
-	}
-	defer kms.CleanupKMS(docker)
-
-	db, err := database.Connect(ctx, cfg.DBConfig, logger)
-	if err != nil {
-		return 1
-	}
-	defer db.Close()
-
-	av := app.NewAppView(db, cfg.DBConfig.AtpDBSchema, cfg.HandleSuffix, logger)
-
-	clients, err := aws.NewClients(ctx, cfg.Env)
-	if err != nil {
-		return 1
-	}
-
-	cs, err := car.NewCarStore(ctx, db, clients.S3, cfg.DBConfig.CarDBSchema, cfg.Env, cfg.CarDir, logger)
-	if err != nil {
-		return 1
-	}
-
-	km, err := keymgr.NewKeyManager(
-		ctx,
-		clients.KMS,
-		clients.S3,
-		cfg.Env,
-		cfg.KeyDir,
-		cfg.RecoveryKey,
-		util.RefreshExpiry,
-		util.AccessExpiry-(5*time.Minute),
-		logger,
-	)
-	if err != nil {
-		return 1
-	}
-
-	plc := plc.NewTestClient(km)
-
-	pds, err := pds.NewPDS(ctx, km, plc, cs, cfg.HandleSuffix, cfg.ServiceUrl, cfg.SecretKey, logger)
-	if err != nil {
-		return 1
-	}
-
-	testService, err = New(ctx, av, pds, logger)
-	if err != nil {
-		return 1
-	}
-
-	go func() {
-		servChErr <- testService.Start(ctx)
-	}()
-
-	time.Sleep(1 * time.Second)
-
-	client = &http.Client{Timeout: 5 * time.Second}
-
-	req, err := http.NewRequestWithContext(ctx, http.MethodGet, baseUrl+"/health", nil)
-	if err != nil {
-		log.Printf("Failed to create health request: %v\n", err)
-		return 1
-	}
-
-	resp, err := client.Do(req)
-	if err != nil {
-		log.Printf("Health request failed: %v\n", err)
-		return 1
-	}
-	defer func() {
-		_ = resp.Body.Close()
-	}()
-	if resp.StatusCode != http.StatusOK {
-		log.Printf("Server did not start properly, got status %v\n", resp.Status)
-		return 1
-	}
-
-	exitCode := m.Run()
-
-	cancel()
-
-	return exitCode
-}
-
-func TestMain(m *testing.M) {
-	servChErr := make(chan error, 1)
-
-	exitCode := setupAndRunTests(m, servChErr)
-
-	if err := <-servChErr; err != nil && !errors.Is(err, context.Canceled) {
-		log.Fatalf("Server exited with error: %v\n", err)
-	}
-	os.Exit(exitCode)
-}
-
-type testRequest struct {
-	method  string
-	path    string
-	body    any
-	headers map[string]string
-}
-
-func (tr *testRequest) handleJsonRequest(t *testing.T) *http.Request {
-	reqBody, err := json.Marshal(tr.body)
-	assert.NoError(t, err, "Failed to marshal request body")
-
-	req, err := http.NewRequestWithContext(
-		context.Background(),
-		tr.method,
-		baseUrl+tr.path,
-		bytes.NewReader(reqBody),
-	)
-	assert.NoError(t, err, "Failed to create HTTP request")
-
-	for k, v := range tr.headers {
-		req.Header.Set(k, v)
-	}
-
-	return req
-}
-
-func (tr *testRequest) handleFormRequest(t *testing.T) *http.Request {
-	form, ok := tr.body.(url.Values)
-	assert.True(t, ok, "Request body must be 'url.Values'")
-
-	req, err := http.NewRequestWithContext(
-		context.Background(),
-		tr.method,
-		baseUrl+tr.path,
-		strings.NewReader(form.Encode()),
-	)
-	assert.NoError(t, err, "Failed to create HTTP request")
-
-	for k, v := range tr.headers {
-		req.Header.Set(k, v)
-	}
-
-	return req
-}
-
-type testResponse struct {
-	status int
-	body   any
-}
-
-func (e *testResponse) getResponse(t *testing.T, req *http.Request) int {
-	resp, err := client.Do(req)
-	assert.NoError(t, err, "HTTP request failed")
-	defer resp.Body.Close()
-
-	assert.Equal(t, e.status, resp.StatusCode)
-
-	if e.body != nil && resp.Body != nil && resp.StatusCode < 300 {
-		decodeErr := json.NewDecoder(resp.Body).Decode(e.body)
-		assert.NoError(t, decodeErr, "Error decoding response body")
-
-		valErr := util.Validate.Struct(e.body)
-		assert.NoError(t, valErr, "Error validating response body")
-	}
-
-	return resp.StatusCode
-}
-
-type testCase struct {
-	name     string
-	request  testRequest
-	response testResponse
-	expected any
-}
-
-func TestCreateAccount(t *testing.T) {
-	tests := []testCase{
-		{
-			"Create Account",
-			testRequest{
-				method: http.MethodPost,
-				path:   "/auth/signup",
-				body: refApp.ServerCreateAccount_Input{
-					DisplayName: "Ken",
-					Email:       email,
-					Handle:      handle,
-					Password:    pw,
-				},
-			},
-			testResponse{
-				status: http.StatusCreated,
-				body:   &refApp.ServerCreateAccount_Output{},
-			},
-			nil,
-		},
-		{
-			"Create Account",
-			testRequest{
-				method: http.MethodPost,
-				path:   "/auth/signup",
-				body: refApp.ServerCreateAccount_Input{
-					DisplayName: "Ken",
-					Email:       "kenny@gmail.com",
-					Handle:      "k1-ng.referendumapp.com",
-					Password:    pw,
-				},
-			},
-			testResponse{
-				status: http.StatusCreated,
-				body:   &refApp.ServerCreateAccount_Output{},
-			},
-			nil,
-		},
-		{
-			"Create Account w/ Duplicate Handle",
-			testRequest{
-				method: http.MethodPost,
-				path:   "/auth/signup",
-				body: refApp.ServerCreateAccount_Input{
-					DisplayName: "Ken",
-					Email:       "kenny@referendumapp.com",
-					Handle:      handle,
-					Password:    pw,
-				},
-			},
-			testResponse{
-				status: http.StatusConflict,
-			},
-			nil,
-		},
-		{
-			"Create Account w/ Duplicate Email",
-			testRequest{
-				method: http.MethodPost,
-				path:   "/auth/signup",
-				body: refApp.ServerCreateAccount_Input{
-					DisplayName: "Ken",
-					Email:       email,
-					Handle:      "ken.referendumapp.com",
-					Password:    pw,
-				},
-			},
-			testResponse{
-				status: http.StatusConflict,
-			},
-			nil,
-		},
-		{
-			"Create Account w/ Invalid Handle",
-			testRequest{
-				method: http.MethodPost,
-				path:   "/auth/signup",
-				body: refApp.ServerCreateAccount_Input{
-					DisplayName: "Ken",
-					Email:       email,
-					Handle:      "k1ng",
-					Password:    pw,
-				},
-			},
-			testResponse{
-				status: http.StatusUnprocessableEntity,
-			},
-			nil,
-		},
-		{
-			"Create Account w/ Invalid Handle",
-			testRequest{
-				method: http.MethodPost,
-				path:   "/auth/signup",
-				body: refApp.ServerCreateAccount_Input{
-					DisplayName: "Ken",
-					Email:       email,
-					Handle:      "k1_ng.referendumapp.com",
-					Password:    pw,
-				},
-			},
-			testResponse{
-				status: http.StatusUnprocessableEntity,
-			},
-			nil,
-		},
-		{
-			"Create Account w/ Invalid Handle",
-			testRequest{
-				method: http.MethodPost,
-				path:   "/auth/signup",
-				body: refApp.ServerCreateAccount_Input{
-					DisplayName: "Ken",
-					Email:       email,
-					Handle:      "k!ng.referendumapp.com",
-					Password:    pw,
-				},
-			},
-			testResponse{
-				status: http.StatusUnprocessableEntity,
-			},
-			nil,
-		},
-		{
-			"Create Account w/ Invalid Handle",
-			testRequest{
-				method: http.MethodPost,
-				path:   "/auth/signup",
-				body: refApp.ServerCreateAccount_Input{
-					DisplayName: "Ken",
-					Email:       "kenny@gmail.com",
-					Handle:      "-k1ng.referendumapp.com",
-					Password:    pw,
-				},
-			},
-			testResponse{
-				status: http.StatusUnprocessableEntity,
-			},
-			nil,
-		},
-		{
-			"Create Account w/ Invalid Handle",
-			testRequest{
-				method: http.MethodPost,
-				path:   "/auth/signup",
-				body: refApp.ServerCreateAccount_Input{
-					DisplayName: "Ken",
-					Email:       email,
-					Handle:      ".k1ng.referendumapp.com",
-					Password:    pw,
-				},
-			},
-			testResponse{
-				status: http.StatusUnprocessableEntity,
-			},
-			nil,
-		},
-		{
-			"Create Account w/ Invalid Email",
-			testRequest{
-				method: http.MethodPost,
-				path:   "/auth/signup",
-				body: refApp.ServerCreateAccount_Input{
-					DisplayName: "Ken",
-					Email:       "kengmail.com",
-					Handle:      handle,
-					Password:    pw,
-				},
-			},
-			testResponse{
-				status: http.StatusUnprocessableEntity,
-			},
-			nil,
-		},
-		{
-			"Create Account w/ Invalid Password",
-			testRequest{
-				method: http.MethodPost,
-				path:   "/auth/signup",
-				body: refApp.ServerCreateAccount_Input{
-					DisplayName: "Ken",
-					Email:       email,
-					Handle:      handle,
-					Password:    "test",
-				},
-			},
-			testResponse{
-				status: http.StatusUnprocessableEntity,
-			},
-			nil,
-		},
-		{
-			"Create Account w/ Invalid Display Name",
-			testRequest{
-				method: http.MethodPost,
-				path:   "/auth/signup",
-				body: refApp.ServerCreateAccount_Input{
-					DisplayName: "Ken.",
-					Email:       email,
-					Handle:      handle,
-					Password:    pw,
-				},
-			},
-			testResponse{
-				status: http.StatusUnprocessableEntity,
-			},
-			nil,
-		},
-		{
-			"Create Account w/ Missing Display Name",
-			testRequest{
-				method: http.MethodPost,
-				path:   "/auth/signup",
-				body: refApp.ServerCreateAccount_Input{
-					Email:    email,
-					Handle:   handle,
-					Password: pw,
-				},
-			},
-			testResponse{
-				status: http.StatusUnprocessableEntity,
-			},
-			nil,
-		},
-		{
-			"Create Account w/ Missing Email",
-			testRequest{
-				method: http.MethodPost,
-				path:   "/auth/signup",
-				body: refApp.ServerCreateAccount_Input{
-					DisplayName: "Ken",
-					Handle:      handle,
-					Password:    pw,
-				},
-			},
-			testResponse{
-				status: http.StatusUnprocessableEntity,
-			},
-			nil,
-		},
-		{
-			"Create Account w/ Missing Handle",
-			testRequest{
-				method: http.MethodPost,
-				path:   "/auth/signup",
-				body: refApp.ServerCreateAccount_Input{
-					DisplayName: "Ken",
-					Email:       email,
-					Password:    pw,
-				},
-			},
-			testResponse{
-				status: http.StatusUnprocessableEntity,
-			},
-			nil,
-		},
-		{
-			"Create Account w/ Missing Password",
-			testRequest{
-				method: http.MethodPost,
-				path:   "/auth/signup",
-				body: refApp.ServerCreateAccount_Input{
-					DisplayName: "Ken",
-					Email:       email,
-					Handle:      handle,
-				},
-			},
-			testResponse{
-				status: http.StatusUnprocessableEntity,
-			},
-			nil,
-		},
-	}
-
-	for _, tc := range tests {
-		t.Run(tc.name, func(t *testing.T) {
-			req := tc.request.handleJsonRequest(t)
-			tc.response.getResponse(t, req)
-		})
-	}
-}
-
-func TestSession(t *testing.T) {
-	createTests := []testCase{
-		{
-			"Create Session w/ Handle",
-			testRequest{
-				method: http.MethodPost,
-				path:   "/auth/login",
-				body: url.Values{
-					"grantType": {"password"},
-					"username":  {handle},
-					"password":  {pw},
-				},
-				headers: map[string]string{"Content-Type": "application/x-www-form-urlencoded"},
-			},
-			testResponse{
-				status: http.StatusCreated,
-				body:   &refApp.ServerCreateSession_Output{},
-			},
-			nil,
-		},
-		{
-			"Create Session w/ Email",
-			testRequest{
-				method: http.MethodPost,
-				path:   "/auth/login",
-				body: url.Values{
-					"grantType": {"password"},
-					"username":  {email},
-					"password":  {pw},
-				},
-				headers: map[string]string{"Content-Type": "application/x-www-form-urlencoded"},
-			},
-			testResponse{
-				status: http.StatusCreated,
-				body:   &refApp.ServerCreateSession_Output{},
-			},
-			nil,
-		},
-		{
-			"Create Session w/ Invalid Grant",
-			testRequest{
-				method: http.MethodPost,
-				path:   "/auth/login",
-				body: url.Values{
-					"grantType": {"test"},
-					"username":  {email},
-					"password":  {pw},
-				},
-				headers: map[string]string{"Content-Type": "application/x-www-form-urlencoded"},
-			},
-			testResponse{
-				status: http.StatusUnprocessableEntity,
-				body:   &refApp.ServerCreateSession_Output{},
-			},
-			nil,
-		},
-		{
-			"Create Session w/ Incorrect Password",
-			testRequest{
-				method: http.MethodPost,
-				path:   "/auth/login",
-				body: url.Values{
-					"grantType": {"password"},
-					"username":  {email},
-					"password":  {"SFKJKLj4923049023jfjd!"},
-				},
-				headers: map[string]string{"Content-Type": "application/x-www-form-urlencoded"},
-			},
-			testResponse{
-				status: http.StatusNotFound,
-				body:   &refApp.ServerCreateSession_Output{},
-			},
-			nil,
-		},
-		{
-			"Create Session w/ Incorrect Username",
-			testRequest{
-				method: http.MethodPost,
-				path:   "/auth/login",
-				body: url.Values{
-					"grantType": {"password"},
-					"username":  {"wrong.referendumapp.com"},
-					"password":  {pw},
-				},
-				headers: map[string]string{"Content-Type": "application/x-www-form-urlencoded"},
-			},
-			testResponse{
-				status: http.StatusNotFound,
-				body:   &refApp.ServerCreateSession_Output{},
-			},
-			nil,
-		},
-		{
-			"Create Session w/ Missing Username",
-			testRequest{
-				method: http.MethodPost,
-				path:   "/auth/login",
-				body: url.Values{
-					"grantType": {"password"},
-					"password":  {pw},
-				},
-				headers: map[string]string{"Content-Type": "application/x-www-form-urlencoded"},
-			},
-			testResponse{
-				status: http.StatusUnprocessableEntity,
-				body:   &refApp.ServerCreateSession_Output{},
-			},
-			nil,
-		},
-		{
-			"Create Session w/ Missing Password",
-			testRequest{
-				method: http.MethodPost,
-				path:   "/auth/login",
-				body: url.Values{
-					"grantType": {"password"},
-					"username":  {handle},
-				},
-				headers: map[string]string{"Content-Type": "application/x-www-form-urlencoded"},
-			},
-			testResponse{
-				status: http.StatusUnprocessableEntity,
-				body:   &refApp.ServerCreateSession_Output{},
-			},
-			nil,
-		},
-	}
-
-	for _, tc := range createTests {
-		t.Run(tc.name, func(t *testing.T) {
-			req := tc.request.handleFormRequest(t)
-			tc.response.getResponse(t, req)
-
-			session, ok := tc.response.body.(*refApp.ServerCreateSession_Output)
-			assert.True(t, ok, "Response body should be *ServerCreateSession_Output")
-
-			if session.AccessToken != "" && session.RefreshToken != "" {
-				accessToken = session.AccessToken
-				refreshToken = session.RefreshToken
-			}
-		})
-	}
-
-	testRefreshToken, err := jwt.NewWithClaims(
-		jwt.SigningMethodHS256,
-		jwt.MapClaims{"sub": "1", "did": "did:plc:fjadklfjlkadsjf", "iss": "test", "type": "refresh"},
-	).SignedString(bytes.NewBufferString("test").Bytes())
-	assert.NoError(t, err, "Error generating test token")
-
-	refreshTests := []testCase{
-		{
-			"Refresh Session",
-			testRequest{
-				method: http.MethodPost,
-				path:   "/auth/refresh",
-				body: refApp.ServerRefreshSession_Input{
-					RefreshToken: refreshToken,
-				},
-			},
-			testResponse{
-				status: http.StatusOK,
-				body:   &refApp.ServerRefreshSession_Output{},
-			},
-			nil,
-		},
-		{
-			"Refresh Session w/ Missing Token",
-			testRequest{
-				method: http.MethodPost,
-				path:   "/auth/refresh",
-				body:   refApp.ServerRefreshSession_Input{},
-			},
-			testResponse{
-				status: http.StatusUnprocessableEntity,
-				body:   &refApp.ServerRefreshSession_Output{},
-			},
-			nil,
-		},
-		{
-			"Refresh Session w/ Invalid Token",
-			testRequest{
-				method: http.MethodPost,
-				path:   "/auth/refresh",
-				body: refApp.ServerRefreshSession_Input{
-					RefreshToken: testRefreshToken,
-				},
-			},
-			testResponse{
-				status: http.StatusUnauthorized,
-				body:   &refApp.ServerRefreshSession_Output{},
-			},
-			nil,
-		},
-	}
-
-	for _, tc := range refreshTests {
-		t.Run(tc.name, func(t *testing.T) {
-			req := tc.request.handleJsonRequest(t)
-			tc.response.getResponse(t, req)
-
-			session, ok := tc.response.body.(*refApp.ServerRefreshSession_Output)
-			assert.True(t, ok, "Response body should be *ServerRefreshSession_Output")
-
-			if session.AccessToken != "" && session.RefreshToken != "" {
-				accessToken = session.AccessToken
-				refreshToken = session.RefreshToken
-				t.Logf("Tokens Refreshed: Access: %s Refresh %s", accessToken, refreshToken)
-			}
-		})
-	}
-
-	testAccessToken, err := jwt.NewWithClaims(
-		jwt.SigningMethodHS256,
-		jwt.MapClaims{"sub": "1", "did": "did:plc:fjadklfjlkadsjf", "iss": "test", "type": "access"},
-	).SignedString(bytes.NewBufferString("test").Bytes())
-	assert.NoError(t, err, "Error generating test token")
-
-	deleteSessionTests := []testCase{
-		{
-			"Delete Session w/ Invalid Token",
-			testRequest{
-				method:  http.MethodDelete,
-				path:    "/auth",
-				headers: map[string]string{"Authorization": "Bearer " + testAccessToken},
-			},
-			testResponse{
-				status: http.StatusBadRequest,
-			},
-			nil,
-		},
-		{
-			"Delete Session",
-			testRequest{
-				method:  http.MethodDelete,
-				path:    "/auth",
-				headers: map[string]string{"Authorization": "Bearer " + accessToken},
-			},
-			testResponse{
-				status: http.StatusOK,
-			},
-			nil,
-		},
-	}
-
-	for _, tc := range deleteSessionTests {
-		t.Run(tc.name, func(t *testing.T) {
-			req := tc.request.handleJsonRequest(t)
-			tc.response.getResponse(t, req)
-		})
-	}
-
-	deleteAcctTests := []testCase{
-		{
-			"Delete Account w/ Invalid Token",
-			testRequest{
-				method:  http.MethodDelete,
-				path:    "/user",
-				headers: map[string]string{"Authorization": "Bearer " + testAccessToken},
-			},
-			testResponse{
-				status: http.StatusBadRequest,
-			},
-			nil,
-		},
-		{
-			"Delete Account",
-			testRequest{
-				method:  http.MethodDelete,
-				path:    "/user",
-				headers: map[string]string{"Authorization": "Bearer " + accessToken},
-			},
-			testResponse{
-				status: http.StatusOK,
-			},
-			nil,
-		},
-		{
-			"Delete Account Again",
-			testRequest{
-				method:  http.MethodDelete,
-				path:    "/user",
-				headers: map[string]string{"Authorization": "Bearer " + accessToken},
-			},
-			testResponse{
-				status: http.StatusBadRequest,
-			},
-			nil,
-		},
-	}
-
-	for _, tc := range deleteAcctTests {
-		t.Run(tc.name, func(t *testing.T) {
-			t.Logf("%s: %s", tc.name, tc.request.headers)
-			req := tc.request.handleJsonRequest(t)
-			sc := tc.response.getResponse(t, req)
-
-			if sc == http.StatusOK {
-				loginReq := testRequest{
-					method: http.MethodPost,
-					path:   "/auth/login",
-					body: url.Values{
-						"grantType": {"password"},
-						"username":  {handle},
-						"password":  {pw},
-					},
-					headers: map[string]string{"Content-Type": "application/x-www-form-urlencoded"},
-				}
-
-				expectedResp := testResponse{
-					status: http.StatusNotFound,
-					body:   nil,
-				}
-
-				checkReq := loginReq.handleFormRequest(t)
-				expectedResp.getResponse(t, checkReq)
-			}
-		})
-	}
-}
diff --git a/user_service/internal/service/service.go b/user_service/internal/service/service.go
deleted file mode 100644
index 6185f7b..0000000
--- a/user_service/internal/service/service.go
+++ /dev/null
@@ -1,97 +0,0 @@
-package service
-
-import (
-	"context"
-	"fmt"
-	"log"
-	"log/slog"
-	"net/http"
-	"time"
-
-	"github.com/go-chi/chi/v5"
-	"github.com/referendumApp/referendumServices/internal/app"
-	"github.com/referendumApp/referendumServices/internal/pds"
-)
-
-// Service abstraction layer around PDS and App View modules
-type Service struct {
-	httpServer *http.Server
-	mux        *chi.Mux
-	av         *app.View
-	pds        *pds.PDS
-	log        *slog.Logger
-	port       int16
-	cancelCh   chan struct{}
-}
-
-// New initialize 'Service' struct, setup HTTP routes, and middleware
-func New(ctx context.Context, av *app.View, pds *pds.PDS, logger *slog.Logger) (*Service, error) {
-	srv := &Service{
-		mux:      chi.NewRouter(),
-		av:       av,
-		pds:      pds,
-		log:      logger,
-		port:     80,
-		cancelCh: make(chan struct{}),
-	}
-
-	srv.mux.Use(func(next http.Handler) http.Handler {
-		return srv.gracefulShutdown(next, srv.cancelCh)
-	})
-
-	srv.mux.Use(srv.logRequest)
-	srv.mux.Use(srv.requestTimeout)
-	srv.setupRoutes()
-
-	srv.httpServer = &http.Server{
-		Addr:         fmt.Sprintf(":%d", srv.port),
-		Handler:      srv.mux,
-		ReadTimeout:  5 * time.Second,
-		WriteTimeout: 30 * time.Second,
-		IdleTimeout:  15 * time.Second,
-	}
-
-	return srv, nil
-}
-
-// Start configure HTTP Server, listen and server requests, handle shutdowns gracefully
-func (s *Service) Start(ctx context.Context) error {
-	errChan := make(chan error, 1)
-
-	// ListenAndServe is blocking so call it in a go routine to run it concurrently
-	go func() {
-		log.Printf("Server starting on port %d\n", s.port)
-		if err := s.httpServer.ListenAndServe(); err != nil && err != http.ErrServerClosed {
-			log.Println("Error listening and serving")
-			errChan <- err
-		}
-	}()
-
-	select {
-	case <-ctx.Done():
-		log.Println("Shutdown signal received")
-		close(s.cancelCh)
-		return s.Shutdown()
-	case err := <-errChan:
-		return fmt.Errorf("server error: %w", err)
-	}
-}
-
-// Shutdown http server
-func (s *Service) Shutdown() error {
-	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
-	defer cancel()
-
-	log.Println("Shutting down HTTP server")
-	if err := s.httpServer.Shutdown(ctx); err != nil {
-		log.Printf("HTTP server shutdown error: %v\n", err)
-		return err
-	}
-
-	if err := s.pds.Shutdown(ctx); err != nil {
-		return err
-	}
-
-	log.Println("Server shutdown complete")
-	return nil
-}
diff --git a/user_service/internal/util/jwt.go b/user_service/internal/util/jwt.go
index 430efeb..0114e46 100644
--- a/user_service/internal/util/jwt.go
+++ b/user_service/internal/util/jwt.go
@@ -25,18 +25,12 @@ const (
 // TokenType type alias for access and refresh token types
 type TokenType string
 
-// Auth token types
+// token types
 const (
 	Access  TokenType = "access"
 	Refresh TokenType = "refresh"
 )
 
-// Token expiry times
-const (
-	AccessExpiry  = 30 * time.Minute
-	RefreshExpiry = 24 * time.Hour
-)
-
 // Auth Constants
 const (
 	DefaultHeaderAuthorization = "Authorization"
@@ -90,20 +84,6 @@ type JWTConfig struct {
 	RefreshExpiry time.Duration
 }
 
-func NewConfig(sk []byte, iss string, method *jwt.SigningMethodHMAC) *JWTConfig {
-	return &JWTConfig{
-		SigningKey:    sk,
-		SigningMethod: method,
-		Issuer:        iss,
-		SubjectKey:    SubjectKey,
-		DidKey:        DidKey,
-		TokenLookup:   DefaultHeaderAuthorization,
-		AuthScheme:    DefaultAuthScheme,
-		TokenExpiry:   AccessExpiry,
-		RefreshExpiry: RefreshExpiry,
-	}
-}
-
 // CreateToken create the JWT token with all the necessary map claims
 func (j *JWTConfig) CreateToken(sub atp.Uid, did string, tokenType TokenType) (string, error) {
 	// Current time
diff --git a/user_service/internal/util/validate.go b/user_service/internal/util/validate.go
index d9b8e25..abdd276 100644
--- a/user_service/internal/util/validate.go
+++ b/user_service/internal/util/validate.go
@@ -8,6 +8,7 @@ import (
 	"unicode"
 
 	"github.com/go-playground/validator/v10"
+	refErr "github.com/referendumApp/referendumServices/internal/error"
 )
 
 // Validate new instance of a go-playground validator
@@ -113,3 +114,50 @@ func ValidateStrongPassword(fl validator.FieldLevel) bool {
 
 	return hasDigit && hasUpper && hasLower && hasSymbol
 }
+
+// HandleFieldError initializes 'ValidationFieldError' struct with the msg and type based on the validation error
+func HandleFieldError(e validator.FieldError) *refErr.ValidationFieldError {
+	var errMsg string
+	var errType refErr.ValidationErrorType
+	var criteria []string
+	switch e.ActualTag() {
+	case "required":
+		errMsg = e.StructField() + " is required"
+		errType = refErr.MissingField
+	case "name":
+		errMsg = "Invalid name format"
+		errType = refErr.InvalidInput
+		criteria = []string{"No special characters allowed", "No numbers allowed", "Check for consecutive spaces"}
+	case "handle":
+		errMsg = "Invalid handle format"
+		errType = refErr.InvalidInput
+	case "email":
+		errMsg = "Invalid email format"
+		errType = refErr.InvalidInput
+	case "max":
+		errMsg = fmt.Sprintf("%s must not exceed %s characters", e.StructField(), e.Param())
+		errType = refErr.InvalidInput
+	case "min":
+		errMsg = fmt.Sprintf("%s must be at least %s characters", e.StructField(), e.Param())
+		errType = refErr.InvalidInput
+	case "strongpassword":
+		errMsg = "Password must contain:"
+		errType = refErr.InvalidInput
+		criteria = []string{
+			"At least one uppercase letter (A-Z)",
+			"At least one digit (0-9)",
+			"At least one special character",
+		}
+	case "username":
+		errMsg = "Invalid email or handle"
+		errType = refErr.InvalidInput
+	case "oneof":
+		errMsg = "Invalid value found"
+		errType = refErr.InvalidInput
+	default:
+		errMsg = "Validation failed"
+		errType = refErr.InvalidInput
+	}
+
+	return refErr.NewValidationFieldError(e.Field(), errMsg, errType, criteria...)
+}
diff --git a/user_service/kms_seed.yaml b/user_service/kms_local/seed.yaml
similarity index 100%
rename from user_service/kms_seed.yaml
rename to user_service/kms_local/seed.yaml
diff --git a/user_service/pkg/lexgen/gen.go b/user_service/lexgen/gen.go
similarity index 100%
rename from user_service/pkg/lexgen/gen.go
rename to user_service/lexgen/gen.go
diff --git a/user_service/pkg/lexgen/schema.go b/user_service/lexgen/schema.go
similarity index 100%
rename from user_service/pkg/lexgen/schema.go
rename to user_service/lexgen/schema.go
diff --git a/user_service/pkg/lexgen/type_schema.go b/user_service/lexgen/type_schema.go
similarity index 100%
rename from user_service/pkg/lexgen/type_schema.go
rename to user_service/lexgen/type_schema.go
diff --git a/user_service/pkg/common/env.go b/user_service/pkg/common/env.go
deleted file mode 100644
index 9d9c6a1..0000000
--- a/user_service/pkg/common/env.go
+++ /dev/null
@@ -1,32 +0,0 @@
-package common
-
-import (
-	"fmt"
-	"os"
-	"strconv"
-)
-
-// GetEnvOrFail returns environment variable or exits the program
-func GetEnvOrFail(key string) (string, error) {
-	val := os.Getenv(key)
-	if val == "" {
-		return "", fmt.Errorf("missing required environment variable: %s", key)
-	}
-
-	return val, nil
-}
-
-// GetIntEnv returns int environment variable or exits the program
-func GetIntEnv(key string) (int, error) {
-	val, err := GetEnvOrFail(key)
-	if err != nil {
-		return 0, err
-	}
-
-	valInt, err := strconv.Atoi(val)
-	if err != nil {
-		return 0, fmt.Errorf("failed to convert %s environment variable to int: %w", key, err)
-	}
-
-	return valInt, nil
-}
diff --git a/user_service/pkg/common/fd.go b/user_service/pkg/common/fd.go
deleted file mode 100644
index 7f371bc..0000000
--- a/user_service/pkg/common/fd.go
+++ /dev/null
@@ -1,31 +0,0 @@
-package common
-
-import (
-	"fmt"
-	"os"
-	"path/filepath"
-)
-
-// FindProjectRoot returns project root based on 'go.mod' file location
-func FindProjectRoot() (string, error) {
-	dir, err := os.Getwd()
-	if err != nil {
-		return "", err
-	}
-
-	// Only return the directory if `go.mod` is found in the filepath
-	for {
-		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
-			if dir == "/" {
-				return ".", nil
-			}
-			return dir, nil
-		}
-
-		parent := filepath.Dir(dir)
-		if parent == dir {
-			return "", fmt.Errorf("could not find project root, no go.mod file found")
-		}
-		dir = parent
-	}
-}
diff --git a/user_service/testutil/docker.go b/user_service/testutil/docker.go
deleted file mode 100644
index 6bfcf2e..0000000
--- a/user_service/testutil/docker.go
+++ /dev/null
@@ -1,118 +0,0 @@
-package testutil
-
-import (
-	"fmt"
-	"log"
-	"os"
-	"os/exec"
-	"strings"
-	"sync"
-
-	"github.com/ory/dockertest/v3"
-	"github.com/ory/dockertest/v3/docker"
-)
-
-var (
-	dockerOnce sync.Once
-	pool       *dockertest.Pool
-	network    *docker.Network
-)
-
-// Docker holds the docker API and network dependencies
-type Docker struct {
-	pool    *dockertest.Pool
-	network *docker.Network
-	Host    string
-}
-
-// SetupDocker creates a pool and network
-func SetupDocker() (*Docker, error) {
-	var dockerErr error
-
-	dockerOnce.Do(func() {
-		pool, dockerErr = dockertest.NewPool("")
-		if dockerErr != nil {
-			log.Printf("Could not create docker pool: %s", dockerErr)
-			return
-		}
-
-		network, dockerErr = pool.Client.CreateNetwork(docker.CreateNetworkOptions{
-			Name: "test-network",
-		})
-		if dockerErr != nil {
-			log.Printf("Could not create network: %s", dockerErr)
-			return
-		}
-	})
-
-	if dockerErr != nil {
-		return nil, dockerErr
-	}
-
-	log.Println("Successfully setup Docker pool and network")
-
-	host := getLocalDockerHost(pool.Client)
-
-	return &Docker{pool: pool, network: network, Host: host}, nil
-}
-
-// CleanupDocker cleans up test docker network
-func (d *Docker) CleanupDocker() {
-	var networkName string
-	if d.network != nil {
-		networkName = d.network.Name
-		if err := d.pool.Client.RemoveNetwork(d.network.ID); err != nil {
-			log.Printf("Could not delete test network: %s", err)
-		}
-	}
-
-	log.Printf("Docker test network removed: %s\n", networkName)
-}
-
-func getLocalDockerHost(c *docker.Client) string {
-	// TODO: This is a workaround for the `host-gateway` mapping bug when running the Docker Engine natively on Linux
-	// https://github.com/docker/buildx/issues/1832
-	if os.Getenv("CI") == "true" {
-		hostIP, err := getHostGatewayIP(c)
-		if err == nil && hostIP != "" {
-			log.Printf("Docker network host IP found: %s", hostIP)
-			return hostIP
-		}
-
-		defaultIP, err := getDefaultRouteIP()
-		if err == nil && defaultIP != "" {
-			log.Printf("Default IP found: %s", defaultIP)
-			return defaultIP
-		}
-	}
-
-	if _, err := os.Stat("/.dockerenv"); err == nil {
-		return "host.docker.internal"
-	}
-
-	return "localhost"
-}
-
-func getHostGatewayIP(c *docker.Client) (string, error) {
-	// Get details about the "bridge" network
-	network, err := c.NetworkInfo("bridge")
-	if err != nil {
-		return "", fmt.Errorf("failed to get bridge network info: %w", err)
-	}
-
-	// Extract the gateway IP address
-	if len(network.IPAM.Config) > 0 {
-		return network.IPAM.Config[0].Gateway, nil
-	}
-
-	return "", fmt.Errorf("no gateway found for bridge network")
-}
-
-func getDefaultRouteIP() (string, error) {
-	cmd := exec.Command("sh", "-c", "ip route | grep default | awk '{print $3}'")
-	out, err := cmd.Output()
-	if err != nil {
-		return "", err
-	}
-	return strings.TrimSpace(string(out)), nil
-}
diff --git a/user_service/testutil/kms.go b/user_service/testutil/kms.go
deleted file mode 100644
index 9cdefb6..0000000
--- a/user_service/testutil/kms.go
+++ /dev/null
@@ -1,161 +0,0 @@
-package testutil
-
-import (
-	"context"
-	"fmt"
-	"log"
-	"os"
-	"sync"
-
-	_ "github.com/lib/pq"
-	"github.com/ory/dockertest/v3"
-	"github.com/ory/dockertest/v3/docker"
-	"github.com/referendumApp/referendumServices/internal/env-config"
-	"github.com/referendumApp/referendumServices/pkg/common"
-)
-
-var (
-	kmsOnce      sync.Once
-	kmsContainer *dockertest.Resource
-	kmsPort      string
-)
-
-// KMSContainer holds information about the local-kms docker container
-type KMSContainer struct {
-	Port         string
-	kmsContainer *dockertest.Resource
-}
-
-// SetupKMS creates a local-kms container
-func (d *Docker) SetupKMS(ctx context.Context, cfg *env.Config) (*KMSContainer, error) {
-	var (
-		initContainer *dockertest.Resource
-		seedContent   []byte
-		kmsErr        error
-	)
-
-	region, err := common.GetEnvOrFail("AWS_REGION")
-	if err != nil {
-		return nil, err
-	}
-	acctId, err := common.GetEnvOrFail("KMS_ACCOUNT_ID")
-	if err != nil {
-		return nil, err
-	}
-	expPort, err := common.GetEnvOrFail("KMS_PORT")
-	if err != nil {
-		return nil, err
-	}
-	pwd, err := common.FindProjectRoot()
-	if err != nil {
-		return nil, err
-	}
-
-	kmsOnce.Do(func() {
-		// Create a Docker volume
-		volumeName := "kms-seed-volume"
-		if _, kmsErr = d.pool.Client.CreateVolume(docker.CreateVolumeOptions{
-			Name: volumeName,
-		}); kmsErr != nil {
-			log.Printf("Failed to create volume: %v", kmsErr)
-			return
-		}
-
-		// Read the seed file content from your container
-		seedContent, kmsErr = os.ReadFile(pwd + "/kms_seed.yaml")
-		if kmsErr != nil {
-			log.Printf("Failed to read seed file: %v", kmsErr)
-			return
-		}
-
-		initContainer, kmsErr = d.pool.RunWithOptions(&dockertest.RunOptions{
-			Repository: "alpine",
-			Tag:        "latest",
-			Cmd: []string{
-				"sh", "-c",
-				"mkdir -p /data && echo '" + string(seedContent) + "' > /data/seed.yaml",
-			},
-			Mounts: []string{
-				fmt.Sprintf("%s:/data", volumeName),
-			},
-		})
-		if kmsErr != nil {
-			log.Printf("Failed to run init container: %v", err)
-			return
-		}
-		defer func() {
-			_ = d.pool.Purge(initContainer)
-		}()
-
-		kmsContainer, kmsErr = d.pool.RunWithOptions(&dockertest.RunOptions{
-			Repository: "kng93/local-kms",
-			Tag:        "latest",
-			Env: []string{
-				fmt.Sprintf("KMS_REGION=%s", region),
-				fmt.Sprintf("KMS_ACCOUNT_ID=%s", acctId),
-				fmt.Sprintf("PORT=%s", expPort),
-			},
-			ExposedPorts: []string{expPort},
-			Mounts:       []string{volumeName + ":/init"},
-			NetworkID:    d.network.ID,
-		})
-		if kmsErr != nil {
-			log.Printf("Could not start KMS container: %v", kmsErr)
-			return
-		}
-
-		kmsPort = kmsContainer.GetPort(expPort + "/tcp")
-		kmsIP := kmsContainer.Container.NetworkSettings.Networks[d.network.Name].IPAddress
-
-		if kmsErr = d.pool.Retry(func() error {
-			if ec, err := kmsContainer.Exec(
-				[]string{
-					"curl",
-					"-f",
-					fmt.Sprintf("http://%s:%s", kmsIP, expPort),
-					"-H",
-					"X-Amz-Target: TrentService.ListKeys",
-					"-H",
-					"Content-Type: application/x-amz-json-1.1",
-					"-d",
-					"{}",
-				},
-				dockertest.ExecOptions{},
-			); err != nil {
-				return err
-			} else if ec != 0 {
-				return fmt.Errorf("KMS container healthcheck exited with code: %d", ec)
-			}
-
-			return nil
-		}); kmsErr != nil {
-			_ = d.pool.Purge(kmsContainer)
-			log.Printf("KMS healthcheck failed: %v", kmsErr)
-			return
-		}
-	})
-
-	if kmsErr != nil {
-		return nil, kmsErr
-	}
-
-	log.Printf("Successfully setup KMS container on port: %s\n", kmsPort)
-
-	if err := os.Setenv("KMS_HOST", d.Host+":"+kmsPort); err != nil {
-		return nil, fmt.Errorf("failed to set KMS_HOST environment variable: %w", err)
-	}
-
-	return &KMSContainer{Port: kmsPort, kmsContainer: kmsContainer}, nil
-}
-
-// CleanupKMS should be called after all tests are done
-func (kc *KMSContainer) CleanupKMS(d *Docker) {
-	// Remove containers
-	if kc.kmsContainer != nil {
-		if err := d.pool.Purge(kc.kmsContainer); err != nil {
-			log.Printf("Could not purge KMS container: %s", err)
-		}
-	}
-
-	log.Println("KMS test resources cleaned up")
-}
diff --git a/user_service/testutil/postgres.go b/user_service/testutil/postgres.go
deleted file mode 100644
index df553b0..0000000
--- a/user_service/testutil/postgres.go
+++ /dev/null
@@ -1,192 +0,0 @@
-package testutil
-
-import (
-	"bytes"
-	"context"
-	"database/sql"
-	"fmt"
-	"log"
-	"sync"
-	"time"
-
-	"github.com/ory/dockertest/v3"
-	"github.com/ory/dockertest/v3/docker"
-	"github.com/referendumApp/referendumServices/internal/env-config"
-)
-
-var (
-	dbOnce       sync.Once
-	postgresDB   *sql.DB
-	pgContainer  *dockertest.Resource
-	postgresPort string
-)
-
-// PostgresContainer holds information about the postgres container
-type PostgresContainer struct {
-	DB          *sql.DB
-	Port        string
-	DBSchema    string
-	pgContainer *dockertest.Resource
-}
-
-// SetupPostgres creates a postgres container and runs migrations
-func (d *Docker) SetupPostgres(ctx context.Context, cfg *env.DBConfig) (*PostgresContainer, error) {
-	var (
-		migrationContainer *dockertest.Resource
-		dbErr              error
-		code               int
-	)
-
-	dbOnce.Do(func() {
-		pgContainer, dbErr = d.pool.RunWithOptions(&dockertest.RunOptions{
-			Repository: "postgres",
-			Tag:        "13",
-			Env: []string{
-				fmt.Sprintf("POSTGRES_USER=%s", cfg.PgUser),
-				fmt.Sprintf("POSTGRES_PASSWORD=%s", cfg.PgPassword),
-				fmt.Sprintf("POSTGRES_DB=%s", cfg.DBName),
-			},
-			NetworkID: d.network.ID,
-		})
-		if dbErr != nil {
-			log.Printf("Could not start postgres: %v", dbErr)
-			return
-		}
-
-		postgresPort = pgContainer.GetPort(cfg.PgPort + "/tcp")
-
-		if dbErr = d.pool.Retry(func() error {
-			var err error
-			postgresDB, err = sql.Open("postgres", fmt.Sprintf(
-				"host=%s port=%s user=%s password=%s dbname=%s sslmode=disable",
-				d.Host, postgresPort, cfg.PgUser, cfg.PgPassword, cfg.DBName,
-			))
-			if err != nil {
-				return err
-			}
-
-			return postgresDB.Ping()
-		}); dbErr != nil {
-			_ = d.pool.Purge(pgContainer)
-			log.Printf("Could not connect to postgres: %v", dbErr)
-			return
-		}
-
-		pgIP := pgContainer.Container.NetworkSettings.Networks[d.network.Name].IPAddress
-		migrationContainer, dbErr = d.pool.RunWithOptions(&dockertest.RunOptions{
-			Repository: "migrations",
-			Tag:        "latest",
-			Env: []string{
-				fmt.Sprintf("POSTGRES_HOST=%s", pgIP),
-				fmt.Sprintf("POSTGRES_PORT=%s", cfg.PgPort),
-				fmt.Sprintf("POSTGRES_USER=%s", cfg.PgUser),
-				fmt.Sprintf("POSTGRES_PASSWORD=%s", cfg.PgPassword),
-				fmt.Sprintf("REFERENDUM_DB_NAME=%s", cfg.DBName),
-			},
-			Cmd:       []string{"alembic", "upgrade", "head"},
-			NetworkID: d.network.ID,
-		})
-		if dbErr != nil {
-			_ = d.pool.Purge(pgContainer)
-			log.Printf("Could not start migration container: %v", dbErr)
-			return
-		}
-		defer func() {
-			_ = d.pool.Purge(migrationContainer)
-		}()
-
-		to := 5 * time.Second
-		toCtx, cancel := context.WithTimeout(ctx, to)
-		defer cancel()
-
-		// Wait for the migration container to exit
-		code, dbErr = d.pool.Client.WaitContainerWithContext(migrationContainer.Container.ID, toCtx)
-		if dbErr != nil {
-			_ = d.pool.Purge(pgContainer)
-			log.Printf("Error waiting for migration container to stop: %v", dbErr)
-			return
-		} else if code != 0 {
-			_ = d.pool.Purge(pgContainer)
-			var logBuffer bytes.Buffer
-			logErr := d.pool.Client.Logs(docker.LogsOptions{
-				Container:    migrationContainer.Container.ID,
-				OutputStream: &logBuffer,
-				ErrorStream:  &logBuffer,
-				Stdout:       true,
-				Stderr:       true,
-			})
-			if logErr == nil {
-				log.Printf("DB migration failed with logs: %s", logBuffer.String())
-			}
-			dbErr = fmt.Errorf("migration container exited with code %d", code)
-			return
-		}
-	})
-
-	if dbErr != nil {
-		return nil, dbErr
-	}
-
-	log.Printf("Successfully setup postgres DB container on port: %s\n", postgresPort)
-
-	cfg.PgHost = d.Host
-	cfg.PgPort = postgresPort
-
-	return &PostgresContainer{
-		DB:          postgresDB,
-		Port:        postgresPort,
-		DBSchema:    cfg.AtpDBSchema,
-		pgContainer: pgContainer,
-	}, nil
-}
-
-// ResetDatabase clears all data, useful between tests
-func (pc *PostgresContainer) ResetDatabase() error {
-	// Get all tables except postgres system tables
-	rows, err := pc.DB.Query(fmt.Sprintf("SELECT tablename FROM pg_tables WHERE schemaname = '%s'", pc.DBSchema))
-	if err != nil {
-		return err
-	}
-	defer func() {
-		_ = rows.Close()
-	}()
-
-	// Disable triggers and truncate each table
-	_, err = pc.DB.Exec("SET session_replication_role = 'replica';")
-	if err != nil {
-		return err
-	}
-
-	for rows.Next() {
-		var tableName string
-		if scanErr := rows.Scan(&tableName); scanErr != nil {
-			return scanErr
-		}
-		_, err = pc.DB.Exec(fmt.Sprintf("TRUNCATE TABLE %s CASCADE;", tableName))
-		if err != nil {
-			return err
-		}
-	}
-
-	if rowErr := rows.Err(); err != nil {
-		return fmt.Errorf("row iteration failed: %w", rowErr)
-	}
-
-	_, err = pc.DB.Exec("SET session_replication_role = 'origin';")
-	return err
-}
-
-// CleanupPostgres should be called after all tests are done
-func (pc *PostgresContainer) CleanupPostgres(d *Docker) {
-	if pc.DB != nil {
-		_ = pc.DB.Close()
-	}
-
-	if pc.pgContainer != nil {
-		if err := d.pool.Purge(pc.pgContainer); err != nil {
-			log.Printf("Could not purge postgres container: %s", err)
-		}
-	}
-
-	log.Println("PostgreSQL test resources cleaned up")
-}
diff --git a/user_service/testutil/s3.go b/user_service/testutil/s3.go
deleted file mode 100644
index ef1352a..0000000
--- a/user_service/testutil/s3.go
+++ /dev/null
@@ -1,106 +0,0 @@
-package testutil
-
-import (
-	"context"
-	"fmt"
-	"log"
-	"os"
-	"sync"
-
-	_ "github.com/lib/pq"
-	"github.com/ory/dockertest/v3"
-	"github.com/referendumApp/referendumServices/pkg/common"
-)
-
-const apiPort = "9000"
-
-var (
-	s3Once      sync.Once
-	s3Container *dockertest.Resource
-	s3Port      string
-)
-
-// S3Container holds information about the minio docker container
-type S3Container struct {
-	Port        string
-	s3Container *dockertest.Resource
-}
-
-// SetupS3 creates a minio container
-func (d *Docker) SetupS3(ctx context.Context) (*S3Container, error) {
-	var s3Err error
-
-	user, err := common.GetEnvOrFail("AWS_ACCESS_KEY_ID")
-	if err != nil {
-		return nil, err
-	}
-	pw, err := common.GetEnvOrFail("AWS_SECRET_ACCESS_KEY")
-	if err != nil {
-		return nil, err
-	}
-	consolePort, err := common.GetEnvOrFail("MINIO_CONSOLE_PORT")
-	if err != nil {
-		return nil, err
-	}
-
-	s3Once.Do(func() {
-		s3Container, s3Err = d.pool.RunWithOptions(&dockertest.RunOptions{
-			Repository: "minio/minio",
-			Tag:        "latest",
-			Env: []string{
-				fmt.Sprintf("MINIO_ROOT_USER=%s", user),
-				fmt.Sprintf("MINIO_ROOT_PASSWORD=%s", pw),
-			},
-			ExposedPorts: []string{consolePort},
-			Cmd:          []string{"server", "/data", "--console-address", fmt.Sprintf(":%s", consolePort)},
-			NetworkID:    d.network.ID,
-		})
-		if s3Err != nil {
-			log.Printf("Could not start S3 container: %v", s3Err)
-			return
-		}
-
-		s3Port = s3Container.GetPort(apiPort + "/tcp")
-		s3IP := s3Container.Container.NetworkSettings.Networks[d.network.Name].IPAddress
-
-		if s3Err = d.pool.Retry(func() error {
-			if ec, err := s3Container.Exec(
-				[]string{"curl", "-f", fmt.Sprintf("http://%s:%s/minio/health/live", s3IP, apiPort)},
-				dockertest.ExecOptions{},
-			); err != nil {
-				return err
-			} else if ec != 0 {
-				return fmt.Errorf("S3 container healthcheck exited with code: %d", ec)
-			}
-
-			return nil
-		}); s3Err != nil {
-			_ = d.pool.Purge(s3Container)
-			log.Printf("S3 healthcheck failed: %v", s3Err)
-			return
-		}
-	})
-
-	if s3Err != nil {
-		return nil, s3Err
-	}
-
-	log.Printf("Successfully setup S3 container on port: %s\n", s3Port)
-
-	if err := os.Setenv("S3_ENDPOINT_URL", "http://"+d.Host+":"+s3Port); err != nil {
-		return nil, fmt.Errorf("failed to set S3_ENDPOINT_URL environment variable: %w", err)
-	}
-
-	return &S3Container{Port: s3Port, s3Container: s3Container}, nil
-}
-
-// CleanupS3 should be called after all tests are done
-func (sc *S3Container) CleanupS3(d *Docker) {
-	if sc.s3Container != nil {
-		if err := d.pool.Purge(sc.s3Container); err != nil {
-			log.Printf("Could not purge minio container: %s", err)
-		}
-	}
-
-	log.Println("S3 test resources cleaned up")
-}
