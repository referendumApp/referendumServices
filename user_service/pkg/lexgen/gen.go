//revive:disable:exported
// Package lex generates Go code for lexicons.

package lexgen

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"unicode"

	"golang.org/x/tools/imports"
)

const (
	EncodingCBOR  = "application/cbor"
	EncodingJSON  = "application/json"
	EncodingJSONL = "application/jsonl"
	EncodingCAR   = "application/vnd.ipld.car"
	EncodingMP4   = "video/mp4"
	EncodingANY   = "*/*"
	Main          = "main"
	AtProto       = "com.atproto"
	Bsky          = "app.bsky"
)

type outputType struct {
	Name      string
	Type      *TypeSchema
	NeedsCbor bool
	NeedsType bool
}

// Build total map of all types defined inside schemas.
// Return map from fully qualified type name to its *TypeSchema
func BuildExtDefMap(ss []*Schema, packages []Package) map[string]*ExtDef {
	out := make(map[string]*ExtDef)
	for _, s := range ss {
		for k, d := range s.Defs {
			d.defMap = out
			d.id = s.ID
			d.defName = k

			var pref string
			for _, pkg := range packages {
				if strings.HasPrefix(s.ID, pkg.Prefix) {
					pref = pkg.Prefix
					break
				}
			}
			d.prefix = pref

			n := s.ID
			if k != Main {
				n = s.ID + "#" + k
			}
			out[n] = &ExtDef{
				Type: d,
			}
		}
	}
	return out
}

type ExtDef struct {
	Type *TypeSchema
}

// TODO: this method is necessary because in lexicon there is no way to know if
// a type needs to be marshaled with a "$type" field up front, you can only
// know for sure by seeing where the type is used.
func FixRecordReferences(schemas []*Schema, defmap map[string]*ExtDef, prefix string) {
	for _, s := range schemas {
		if !strings.HasPrefix(s.ID, prefix) {
			continue
		}

		tps := s.AllTypes(prefix, defmap)
		for _, t := range tps {
			if t.Type.Type == Record {
				// t.NeedsType = true
				t.Type.needsType = true
			}

			if t.Type.Type == Union {
				for _, r := range t.Type.Refs {
					if strings.HasPrefix(r, AtProto) || strings.HasPrefix(r, Bsky) {
						continue
					}

					if r[0] == '#' {
						r = s.ID + r
					}

					if _, known := defmap[r]; !known {
						panic(fmt.Sprintf("reference to unknown record type: %s", r))
					}

					if t.NeedsCbor {
						defmap[r].Type.needsCbor = true
					}
				}
			}
		}
	}
}

func printerf(w io.Writer) func(format string, args ...any) {
	return func(format string, args ...any) {
		if _, err := fmt.Fprintf(w, format, args...); err != nil {
			log.Fatalf("Failed to write generated code: %s", format)
		}
	}
}

func GenCodeForSchema(pkg Package, reqcode bool, s *Schema, packages []Package, defmap map[string]*ExtDef) error {
	err := os.MkdirAll(pkg.Outdir, 0755) //nolint:gosec
	if err != nil {
		return fmt.Errorf("%s: could not mkdir, %w", pkg.Outdir, err)
	}
	fname := filepath.Join(pkg.Outdir, s.Name()+".go")
	buf := new(bytes.Buffer)
	pf := printerf(buf)

	s.prefix = pkg.Prefix
	for _, d := range s.Defs {
		d.prefix = pkg.Prefix
	}

	// Add the standard Go generated code header as recognized by GitHub, VS Code, etc.
	// See https://golang.org/s/generatedcode.
	pf("// Code generated by cmd/lexgen (see Makefile's lexgen); DO NOT EDIT.\n\n")

	pf("package %s\n\n", pkg.GoPackage)

	pf("// schema: %s\n\n", s.ID)

	pf("import (\n")
	pf("\t\"context\"\n")
	pf("\t\"fmt\"\n")
	pf("\t\"encoding/json\"\n")
	pf("\tcbg \"github.com/whyrusleeping/cbor-gen\"\n")
	pf("\tcomatproto \"github.com/bluesky-social/indigo/api/atproto\"\n")
	pf("\tappbsky \"github.com/bluesky-social/indigo/api/bsky\"\n")
	pf("\t\"github.com/bluesky-social/indigo/xrpc\"\n")
	pf("\t\"github.com/bluesky-social/indigo/lex/util\"\n")

	pf("\t\"github.com/referendumApp/referendumServices/internal/domain/atp\"\n")
	pf("\t\"github.com/referendumApp/referendumServices/internal/repo\"\n")
	for _, xpkg := range packages {
		if xpkg.Prefix != pkg.Prefix {
			pf("\t%s %q\n", importNameForPrefix(xpkg.Prefix), xpkg.Import)
		}
	}
	pf(")\n\n")

	tps := s.AllTypes(pkg.Prefix, defmap)

	if err := writeDecoderRegister(buf, tps); err != nil {
		return err
	}

	sort.Slice(tps, func(i, j int) bool {
		return tps[i].Name < tps[j].Name
	})
	for _, ot := range tps {
		log.Printf("TYPE: %s, NeedCBOR: %v, NeedType: %v\n", ot.Name, ot.NeedsCbor, ot.NeedsType)
		if err := ot.Type.WriteType(ot.Name, buf); err != nil {
			return err
		}
	}

	// reqcode is always True
	if reqcode {
		main, ok := s.Defs[Main]
		if ok {
			if err := writeMethods(s.ID, pkg.Prefix, main, buf); err != nil {
				return err
			}
		}
	}

	if err := writeCodeFile(buf.Bytes(), fname); err != nil {
		return err
	}

	return nil
}

func writeDecoderRegister(w io.Writer, tps []outputType) error {
	var buf bytes.Buffer
	outf := printerf(&buf)

	for _, t := range tps {
		if t.Type.needsType {
			id := t.Type.id
			if t.Type.defName != "" {
				id = id + "#" + t.Type.defName
			}
			if buf.Len() == 0 {
				outf("func init() {\n")
			}
			outf("util.RegisterType(%q, &%s{})\n", id, t.Name)
		}
	}
	if buf.Len() == 0 {
		return nil
	}
	outf("}\n")
	_, err := w.Write(buf.Bytes())
	return err
}

func writeCodeFile(b []byte, fname string) error {
	fixed, err := imports.Process(fname, b, nil)
	if err != nil {
		werr := os.WriteFile("temp", b, 0600)
		if werr != nil {
			return werr
		}
		return fmt.Errorf("failed to format output of %q with goimports: %w (wrote failed file to ./temp)", fname, err)
	}

	if err := os.WriteFile(fname, fixed, 0600); err != nil {
		return err
	}

	return nil
}

func writeMethods(id string, prefix string, ts *TypeSchema, w io.Writer) error {
	typename := nameFromID(id, prefix)
	switch ts.Type {
	case "token":
		n := ts.id
		if ts.defName != Main {
			n += "#" + ts.defName
		}

		if _, err := fmt.Fprintf(w, "const %s = %q\n", typename, n); err != nil {
			return err
		}
		return nil
	case Record:
		return ts.writeStorageMethods(typename, id, w)
	case Query:
		return ts.WriteRPC(w, typename, fmt.Sprintf("%s_Input", typename))
	case Procedure:
		switch {
		case ts.Input == nil || ts.Input.Schema == nil || ts.Input.Schema.Type == Object:
			return ts.WriteRPC(w, typename, fmt.Sprintf("%s_Input", typename))
		case ts.Input.Schema.Type == "ref":
			inputname, _ := ts.namesFromRef(ts.Input.Schema.Ref)
			return ts.WriteRPC(w, typename, inputname)
		default:
			return fmt.Errorf("unhandled input type: %s", ts.Input.Schema.Type)
		}
	case Object, String:
		return nil
	case Subscription:
		// TODO: should probably have some methods generated for this
		return nil
	default:
		return fmt.Errorf("unrecognized lexicon type %q", ts.Type)
	}
}

func capitalizeFirst(s string) string {
	if s == "" {
		return ""
	}
	r := []rune(s)
	r[0] = unicode.ToUpper(r[0])
	return string(r)
}

func nameFromID(id, prefix string) string {
	parts := strings.Split(strings.TrimPrefix(id, prefix), ".")
	var tname string
	for _, s := range parts {
		if strings.Contains(s, "#") {
			moreParts := strings.Split(s, "#")
			formatted := make([]string, len(moreParts))
			for i, p := range moreParts {
				formatted[i] = capitalizeFirst(p)
			}
			tname += strings.Join(formatted, "_")
		} else {
			tname += capitalizeFirst(s)
		}
	}

	return tname
}

func orderedMapIter[T any](m map[string]T, cb func(string, T) error) error {
	var keys []string
	for k := range m {
		keys = append(keys, k)
	}

	sort.Strings(keys)

	for _, k := range keys {
		if err := cb(k, m[k]); err != nil {
			return err
		}
	}
	return nil
}

func CreateHandlerStub(pkg string, impmap map[string]string, dir string, schemas []*Schema, handlers bool) error {
	buf := new(bytes.Buffer)

	if err := WriteXrpcServer(buf, schemas, pkg, impmap); err != nil {
		return err
	}

	fname := filepath.Join(dir, "stubs.go")
	if err := writeCodeFile(buf.Bytes(), fname); err != nil {
		return err
	}

	if handlers {
		buf := new(bytes.Buffer)

		if err := WriteServerHandlers(buf, schemas, pkg, impmap); err != nil {
			return err
		}

		fname := filepath.Join(dir, "handlers.go")
		if err := writeCodeFile(buf.Bytes(), fname); err != nil {
			return err
		}
	}

	return nil
}

func importNameForPrefix(prefix string) string {
	return strings.Join(strings.Split(prefix, "."), "")
}

func WriteServerHandlers(w io.Writer, schemas []*Schema, pkg string, impmap map[string]string) error {
	pf := printerf(w)
	pf("package %s\n\n", pkg)
	pf("import (\n")
	pf("\t\"context\"\n")
	pf("\t\"fmt\"\n")
	pf("\t\"encoding/json\"\n")
	pf("\t\"github.com/bluesky-social/indigo/xrpc\"\n")
	for k, v := range impmap {
		pf("\t%s\"%s\"\n", importNameForPrefix(k), v)
	}
	pf(")\n\n")

	for _, s := range schemas {
		var prefix string
		for k := range impmap {
			if strings.HasPrefix(s.ID, k) {
				prefix = k
				break
			}
		}

		main, ok := s.Defs[Main]
		if !ok {
			log.Printf("WARNING: schema %q doesn't have a main def\n", s.ID)
			continue
		}

		if main.Type == Procedure || main.Type == Query {
			fname := idToTitle(s.ID)
			tname := nameFromID(s.ID, prefix)
			impname := importNameForPrefix(prefix)
			if err := main.WriteHandlerStub(w, fname, tname, impname); err != nil {
				return err
			}
		}
	}

	return nil
}

func WriteXrpcServer(w io.Writer, schemas []*Schema, pkg string, impmap map[string]string) error {
	pf := printerf(w)
	pf("package %s\n\n", pkg)
	pf("import (\n")
	pf("\t\"context\"\n")
	pf("\t\"fmt\"\n")
	pf("\t\"encoding/json\"\n")
	pf("\t\"github.com/bluesky-social/indigo/xrpc\"\n")
	pf("\t\"github.com/labstack/echo/v4\"\n")

	var prefixes []string
	if err := orderedMapIter[string](impmap, func(k, v string) error {
		prefixes = append(prefixes, k)
		pf("\t%s\"%s\"\n", importNameForPrefix(k), v)
		return nil
	}); err != nil {
		return err
	}
	pf(")\n\n")

	ssets := make(map[string][]*Schema)
	for _, s := range schemas {
		var pref string
		for _, p := range prefixes {
			if strings.HasPrefix(s.ID, p) {
				pref = p
				break
			}
		}
		if pref == "" {
			return fmt.Errorf("no matching prefix for schema %q (tried %s)", s.ID, prefixes)
		}

		ssets[pref] = append(ssets[pref], s)
	}

	for _, p := range prefixes {
		ss := ssets[p]

		pf("func (s *Server) RegisterHandlers%s(e *echo.Echo) error {\n", idToTitle(p))
		for _, s := range ss {
			main, ok := s.Defs[Main]
			if !ok {
				continue
			}

			var verb string
			switch main.Type {
			case Query:
				verb = "GET"
			case Procedure:
				verb = "POST"
			default:
				continue
			}

			pf("e.%s(\"/xrpc/%s\", s.Handle%s)\n", verb, s.ID, idToTitle(s.ID))
		}

		pf("return nil\n}\n\n")

		for _, s := range ss {
			var prefix string
			for k := range impmap {
				if strings.HasPrefix(s.ID, k) {
					prefix = k
					break
				}
			}

			main, ok := s.Defs[Main]
			if !ok {
				continue
			}

			if main.Type == Procedure || main.Type == Query {
				fname := idToTitle(s.ID)
				tname := nameFromID(s.ID, prefix)
				impname := importNameForPrefix(prefix)
				if err := main.WriteRPCHandler(w, fname, tname, impname); err != nil {
					return fmt.Errorf("writing handler for %s: %w", s.ID, err)
				}
			}
		}
	}

	return nil
}

func idToTitle(id string) string {
	var fname string
	for p := range strings.SplitSeq(".", id) {
		fname += capitalizeFirst(p)
	}
	return fname
}

type Package struct {
	GoPackage string `json:"package"`
	Prefix    string `json:"prefix"`
	Outdir    string `json:"outdir"`
	Import    string `json:"import"`
}

// ParsePackages reads a json blob which should be an array of Package{} objects.
func ParsePackages(jsonBytes []byte) ([]Package, error) {
	var packages []Package
	err := json.Unmarshal(jsonBytes, &packages)
	if err != nil {
		return nil, err
	}
	return packages, nil
}

func Run(schemas []*Schema, packages []Package) error {
	defmap := BuildExtDefMap(schemas, packages)

	for _, pkg := range packages {
		prefix := pkg.Prefix
		FixRecordReferences(schemas, defmap, prefix)
	}

	for _, pkg := range packages {
		for _, s := range schemas {
			if !strings.HasPrefix(s.ID, pkg.Prefix) {
				continue
			}

			if err := GenCodeForSchema(pkg, true, s, packages, defmap); err != nil {
				return fmt.Errorf("failed to process schema %q: %w", s.path, err)
			}
		}
	}
	return nil
}
